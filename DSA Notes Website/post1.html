<!DOCTYPE html>
<html>
<head>
	<title>My Blog Post</title>

<script>

    // some preventions from users

            body {
        -webkit-user-select: none;  /* Chrome, Safari, Opera */
        -moz-user-select: none;     /* Firefox */
        -ms-user-select: none;      /* IE 10+ */
        user-select: none;          /* Standard syntax */
        }
        p {
        -webkit-user-select: text; /* Safari */        
        -moz-user-select: text; /* Firefox */
        -ms-user-select: text; /* IE10+/Edge */
        user-select: text; /* Standard */
        }

        /* Disable long-press actions on touch devices */

  -webkit-touch-callout: none; /* Safari */
  -ms-touch-action: none; /* IE10 */
  touch-action: none; /* Standard */

/* Disable cursor dragging and text selection on touch devices */

  touch-action: none;



    </script>
           
        <script>
  // Disable right-click
  document.addEventListener('contextmenu', function(e) {
    e.preventDefault();
  });

  // Disable double-click
  var lastClickTime = 0;
  document.addEventListener('click', function(e) {
    var clickTime = new Date().getTime();
    if (clickTime - lastClickTime < 500) {
      e.preventDefault();
    }
    lastClickTime = clickTime;
  });
</script>
        <script>
  // Disable printing
  window.print = function() {
    alert('Printing is not allowed on this page.');
  };
</script>

<style>
  @media print {
    body * {
      display: none !important;
    }
  }
</style>

   <script>
    document.addEventListener('contextmenu', event => event.preventDefault());

    document.addEventListener('dblclick', function(event) {
  event.preventDefault();
  alert(' Double-clicking/Printing is not allowed on this page. Contact: Administrator(Mr Brijesh)');

  document.addEventListener('contextmenu', function(event) {
  event.preventDefault();
  alert(' Double-clicking/Printing is not allowed on this page. Contact: Administrator(Mr Brijesh)');
});

});

var element = document.getElementById("myElement");

element.addEventListener("touchstart", function(event) {
    if (event.touches.length > 1) {
        event.preventDefault();
    }
}, false);

element.addEventListener("touchend", function(event) {
    if (event.touches.length > 0) {
        event.preventDefault();
    }
}, false);

</script>


	<style>
        // Designing.............
        
		body {
			font-family: Arial, sans-serif;
			background-color: #f2f2f2;
			color: #333;
			margin: 0;
			padding: 0;
		}

		header {
			background-color: transparent;
			color: #fff;
			padding: 20px;
			text-align: center;
           
            

            
		}

		h1 {
			font-size: 36px;
			margin: 0;
			padding: 0;
            text-shadow: 1px 1px 0 #ccc, 3px 3px 0 #ccc, 4px 4px 0 #ccc, 5px 5px 0 #ccc, 6px 6px 0 #ccc;
            color:black;
            
        
		}

       
        .topics{
			font-size: 36px;
			margin: 0;
			padding: 0;
            
            font-size: 36px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #ccc, 3px 3px 0 #ccc, 4px 4px 0 #ccc, 5px 5px 0 #ccc, 6px 6px 0 #ccc;
            
           }

		main {
			background-color: #fff;
			box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.2), 
                        inset 0px 0px 10px rgba(255, 255, 255, 0.5), 
                        inset 0px 0px 20px rgba(0, 0, 0, 0.5);
			padding: 20px;
			margin: 30px;
		}

		p {
			font-size: 16px;
			line-height: 1.5;
			margin: 0 0 20px 0;
            
		}

		ul {
			margin: 0;
			padding: 0;
			list-style: none;
		}

		ul li:before {
			content: "â€¢";
			color: #333;
			margin-right: 10px;
		}

		a {
			color: #333;
			text-decoration: none;
			font-weight: bold;
		}

		a:hover {
			color: #666;
		}
	</style>


    <style>
        <script>
            <script>
  // Get the button element
  var btn = document.getElementById("go-top-btn");

  // Show the button when the user scrolls down 20px
  window.onscroll = function() {
    if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
      btn.style.display = "block";
    } else {
      btn.style.display = "none";
    }
  };

  // When the user clicks the button, scroll to the top of the page
  btn.onclick = function() {
    document.body.scrollTop = 0;
    document.documentElement.scrollTop = 0;
  };
</script>

        </script>
        #go-top-btn {
  position: fixed;
  bottom: 20px;
  right: 20px;
  z-index: 9999;
  background-color: #333;
  color: #fff;
  padding: 10px 20px;
  border-radius: 50%;
  font-size: 16px;
  display: none;
}

    </style>

    <style>

        .topic-card {
  position: relative;
  width: auto;
  height: auto;
  margin: 20px;
  border-radius: 5px;
  overflow: hidden;
  box-shadow: 0px 5px 20px rgba(0, 0, 0, 0.3);
  transition: all 0.5s ease;
}

.topic-card:hover {
  transform: translateY(-10px);
  box-shadow: 0px 10px 30px rgba(0, 0, 0, 0.5);
}

.topic-card-image {
  width: 100%;
  height: auto;
  background: url(https://example.com/image.jpg);
  background-size: cover;
  background-position: center center;
  transition: all 0.5s ease;
}

.topic-card:hover .card-image {
  transform: translateY(-30px);
}

.topic-card-content {
  position: absolute;
  bottom: 0;
  width: 100%;
  height: auto;
  padding: 20px;
  background-color: #fff;
  transition: all 0.5s ease;
}

.card:hover .card-content {
  transform: translateY(-30px);
}

.topic-card-content h2 {
  margin: 0;
  font-size: 24px;
  font-weight: bold;
}

.topic-card-content p {
  margin: 10px 0 0;
  font-size: 16px;
  line-height: 1.5;
}

        </style>
</head>
<body oncontextmenu="return false;">
	<header>
        <fieldset class="topic-card">
		<h1>Data Structure Using C/C++</h1>
        </fieldset >
	</header>
	<main>
		
        <fieldset class="topic-card">
        <p class="c13"><span  class="topics" >Topics:</span>

		<ul>
			<li>Address calculation</li>

			<li>Address Calculation Programm</li>

			<li>Array address calculation</li>

            <li>Pre order , post order traversal</li>

            <li>Construct tree from traversal</li>

            <li>Warshal and Dijkstra algo And distance calculation</li>

            <li>Minimum spanning tree</li>

            <li>Prim and kruskal</li>

            <li>Huffman coding</li>

            <li>Binary search tree</li>

            <li>AVL tree</li>

            <li>B tree</li>

            <li> Dfs and bfs</li>

            <li>Algorithm for stack, queue and circular queue</li>

            <li> Types of hashing And types of collision</li>

            <li> Tower of hanoi</li>

            <li> Linear search</li>

            <li> Binary search</li>

            <li> Recursive binary search</li>

            <li>Sort the sequence ( bubble, selection, insertion, merge, quick, radix)</li>

            <li>Representation of sparse,  graph and trees</li>

		</ul>

    </fieldset>





		<p> 

              

           
    <fieldset class="topic-card"> 
      <p class="c13"><span  class="topics" >Content</span>  
    </fieldset>
               
    <fieldset class="topic-card">
               <p class="c13"><span class="topics">Address calculation:</span>
               
               
               <span class="c11">&nbsp;This refers to the process of determining the physical memory address of a variable or data structure in a computer&#39;s memory. This is important for optimizing memory usage and ensuring efficient access to data.</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c13"><span class="c19">C program that demonstrates address calculation:</span></p><p class="c27 c13 c21"><span class="c23">Address calculation:</span></p><ul class="c14 lst-kix_4nvhequxmq5u-0 start"><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">If the base address of an array is 1000 and the size of each element is 4 bytes, the address of the third element can be calculated as: 1000 + (3 * 4) = 1012.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">To calculate the address of a struct member, the offset of the member from the beginning of the struct is added to the base address of the struct.</span></li></ul><p class="c27 c13 c21"><span class="c23">#include &lt;stdio.h&gt;</span></p><p class="c27 c13 c21 c26"><span class="c23"></span></p><p class="c27 c13 c21"><span class="c23">int main() {</span></p><p class="c27 c13 c21"><span class="c23">&nbsp; &nbsp;int var = 10;</span></p><p class="c27 c13 c21"><span class="c23">&nbsp; &nbsp;int *ptr = &amp;var;</span></p><p class="c27 c13 c21"><span class="c23">&nbsp; &nbsp;</span></p><p class="c27 c13 c21"><span class="c23">&nbsp; &nbsp;printf(&quot;Address of var variable: %p\n&quot;, &amp;var);</span></p><p class="c27 c13 c21"><span class="c23">&nbsp; &nbsp;printf(&quot;Address stored in ptr variable: %p\n&quot;, ptr);</span></p><p class="c27 c13 c21"><span class="c23">&nbsp; &nbsp;printf(&quot;Value of var variable: %d\n&quot;, var);</span></p><p class="c27 c13 c21"><span class="c23">&nbsp; &nbsp;printf(&quot;Value of *ptr variable: %d\n&quot;, *ptr);</span></p><p class="c27 c13 c21 c26"><span class="c23"></span></p><p class="c27 c13 c21"><span class="c23">&nbsp; &nbsp;return 0;</span></p><p class="c27 c13 c21"><span class="c23">}</span></p><p class="c27 c13 c21 c26"><span class="c23"></span></p><p class="c27 c13 c21"><span class="c35">In this program, we create a variable </span><span class="c22">var</span><span class="c35">&nbsp;with the value of </span><span class="c22">10</span><span class="c35">, and a pointer </span><span class="c22">ptr</span><span class="c35">&nbsp;that points to the address of </span><span class="c22">var</span><span class="c35">. We then use the </span><span class="c22">&amp;</span><span class="c35">&nbsp;operator to print out the memory addresses of </span><span class="c22">var</span><span class="c35">&nbsp;and </span><span class="c22">ptr</span><span class="c35">, as well as the values of </span><span class="c22">var</span><span class="c35">&nbsp;and </span><span class="c22">*ptr</span><span class="c23">&nbsp;(which dereferences the pointer to retrieve the value stored at the memory address it points to).</span></p><p class="c27 c13 c21"><span class="c23">Here is a sample output of the program:</span></p><p class="c27 c13 c21"><span class="c23">Address of var variable: 0x7ffc8c3d0bdc</span></p><p class="c27 c13 c21"><span class="c23">Address stored in ptr variable: 0x7ffc8c3d0bdc</span></p><p class="c27 c13 c21"><span class="c23">Value of var variable: 10</span></p><p class="c27 c13 c21"><span class="c23">Value of *ptr variable: 10</span></p><p class="c27 c13 c21"><span class="c19">As you can see, both the address of </span><span class="c37 c21">var</span><span class="c19">&nbsp;and the address stored in </span><span class="c37 c21">ptr</span><span class="c19">&nbsp;are the same, indicating that </span><span class="c37 c21">ptr</span><span class="c19">&nbsp;points to the memory location of </span><span class="c37 c21">var</span><span class="c19">. This is the process of address calculation in action, and it allows us to efficiently access and manipulate data stored in memory.</span></p><p class="c27 c13 c21 c26"><span class="c23"></span></p><p class="c13 c26"><span class="c11"></span></p><p class="c13 c26"><span class="c11"></span></p>
               
</fieldset>
<fieldset class="topic-card">
               <p class="c13"><span class="topics">Array address calculation:</span>
               
               
               <span class="c11">&nbsp;This refers specifically to the process of calculating the memory address of an element in an array, which involves using the base address of the array and the index of the element.</span></p><p class="c27 c13 c21"><span class="c23">Array address calculation:</span></p><ul class="c14 lst-kix_6t7dh6kuzgcl-0 start"><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">If the base address of an array is 2000 and the size of each element is 2 bytes, the address of the fifth element can be calculated as: 2000 + (5 * 2) = 2010.</span></li></ul><p class="c13"><span class="c8">#include &lt;stdio.h&gt;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">int main() {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp;int arr[5] = {10, 20, 30, 40, 50};</span></p><p class="c13"><span class="c8">&nbsp; &nbsp;int i;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp;for(i = 0; i &lt; 5; i++) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; printf(&quot;Address of arr[%d] = %p\n&quot;, i, &amp;arr[i]);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp;}</span></p><p class="c13"><span class="c8">&nbsp; &nbsp;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp;return 0;</span></p><p class="c13"><span class="c8">}</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">Address of arr[0] = 0x7fff5fbff7a0</span></p><p class="c13"><span class="c11 c53">Address of arr[1] = 0x7fff5fbff7a4</span></p><p class="c13"><span class="c11 c53">Address of arr[2] = 0x7fff5fbff7a8</span></p><p class="c13"><span class="c11 c53">Address of arr[3] = 0x7fff5fbff7ac</span></p><p class="c13"><span class="c11 c53">Address of arr[4] = 0x7fff5fbff7b0</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c27 c13 c21"><span class="c35">In this example, we have an integer array </span><span class="c22">arr</span><span class="c35">&nbsp;of size 5, and we use a </span><span class="c22">for</span><span class="c35">&nbsp;loop to print the memory addresses of each element in the array. We use the </span><span class="c22">&amp;</span><span class="c23">&nbsp;operator to get the memory address of each element.</span></p><p class="c27 c13 c21"><span class="c23">He| 10 | 20 | 30 | 40 | 50 |</span></p><p class="c27 c13 c21"><span class="c23">---------------------------</span></p><p class="c27 c13 c21"><span class="c23">^</span></p><p class="c27 c13 c21"><span class="c23">|</span></p><p class="c27 c13 c21"><span class="c23">&amp;arr[0]</span></p><p class="c27 c13 c21 c26"><span class="c23"></span></p><p class="c27 c13 c21"><span class="c23">re&#39;s a figure to help visualize how the memory is laid out for the array:</span></p><p class="c13 c26"><span class="c11"></span></p>
               
           </fieldset>
           <fieldset class="topic-card">

               <p class="c13"><span class="topics">Pre-order and post-order traversal:</span>
               
               
               <span class="c11">&nbsp;These are two methods of traversing a binary tree, where pre-order traversal visits the root node first, then the left subtree, and then the right subtree, while post-order traversal visits the left subtree, then the right subtree, and then the root node.</span></p><p class="c27 c13 c21"><span class="c23">Tree traversal is a common operation performed on binary trees in computer science. Pre-order and post-order traversal are two methods of traversing a binary tree.</span></p><p class="c27 c13 c21"><span class="c23">Pre-order traversal involves visiting the root node first, then visiting the left subtree, and finally visiting the right subtree. Post-order traversal involves visiting the left subtree first, then visiting the right subtree, and finally visiting the root node.</span></p><p class="c27 c13 c21"><span class="c23">Here is an example binary tree:</span></p><p class="c13"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</span></p><p class="c13"><span class="c11">&nbsp; &nbsp; &nbsp; &nbsp;/ &nbsp; \</span></p><p class="c13"><span class="c11">&nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; 3</span></p><p class="c13"><span class="c11">&nbsp; &nbsp; &nbsp;/ \ &nbsp; / \</span></p><p class="c13"><span class="c11">&nbsp; &nbsp; 4 &nbsp; 5 6 &nbsp; 7</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c27 c13 c21"><span class="c23">In pre-order traversal, the nodes would be visited in the order: 1, 2, 4, 5, 3, 6, 7. In post-order traversal, the nodes would be visited in the order: 4, 5, 2, 6, 7, 3, 1.</span></p><p class="c27 c13 c21"><span class="c23">Here is a C program that demonstrates pre-order and post-order traversal of a binary tree:</span></p><p class="c13"><span class="c8">#include &lt;stdio.h&gt;</span></p><p class="c13"><span class="c8">#include &lt;stdlib.h&gt;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">// Node structure</span></p><p class="c13"><span class="c8">struct Node {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; int data;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; struct Node* left;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; struct Node* right;</span></p><p class="c13"><span class="c8">};</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">// Function to create a new node</span></p><p class="c13"><span class="c8">struct Node* newNode(int data) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; struct Node* node = (struct Node*)malloc(sizeof(struct Node));</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; node-&gt;data = data;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; node-&gt;left = NULL;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; node-&gt;right = NULL;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; return node;</span></p><p class="c13"><span class="c8">}</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">// Pre-order traversal function</span></p><p class="c13"><span class="c8">void preOrder(struct Node* root) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; if (root == NULL) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; return;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; printf(&quot;%d &quot;, root-&gt;data);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; preOrder(root-&gt;left);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; preOrder(root-&gt;right);</span></p><p class="c13"><span class="c8">}</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">// Post-order traversal function</span></p><p class="c13"><span class="c8">void postOrder(struct Node* root) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; if (root == NULL) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; return;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; postOrder(root-&gt;left);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; postOrder(root-&gt;right);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; printf(&quot;%d &quot;, root-&gt;data);</span></p><p class="c13"><span class="c8">}</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">int main() {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; // Create binary tree</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; struct Node* root = newNode(1);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; root-&gt;left = newNode(2);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; root-&gt;right = newNode(3);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; root-&gt;left-&gt;left = newNode(4);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; root-&gt;left-&gt;right = newNode(5);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; root-&gt;right-&gt;left = newNode(6);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; root-&gt;right-&gt;right = newNode(7);</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; // Print tree using pre-order traversal</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; printf(&quot;Pre-order traversal: &quot;);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; preOrder(root);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; printf(&quot;\n&quot;);</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; // Print tree using post-order traversal</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; printf(&quot;Post-order traversal: &quot;);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; postOrder(root);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; printf(&quot;\n&quot;);</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; return 0;</span></p><p class="c13"><span class="c8">}</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c13"><span class="c23 c21">And here is a figure that illustrates the pre-order and post-order traversal of the example binary tree:</span></p><p class="c13"><span class="c23 c21">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;1</span></p><p class="c13"><span class="c23 c21">&nbsp; &nbsp; &nbsp; &nbsp;/ &nbsp; \</span></p><p class="c13"><span class="c23 c21">&nbsp; &nbsp; &nbsp; 2 &nbsp; &nbsp; 3</span></p><p class="c13"><span class="c23 c21">&nbsp; &nbsp; &nbsp;/ \ &nbsp; / \</span></p><p class="c13"><span class="c23 c21">&nbsp; &nbsp; 4 &nbsp; 5 6 &nbsp; 7</span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13"><span class="c23 c21">Pre-order traversal: 1 2 4 5 3 6 7</span></p><p class="c13"><span class="c23 c21">Post-order traversal: 4 5 2 6 7 3 1</span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13 c26"><span class="c23 c21"></span></p>
               
               </fieldset>
           <fieldset class="topic-card">
               
               <p class="c13"><span class="topics">Constructing a tree from traversal:</span>
               
               
               <span class="c11">&nbsp;This involves constructing a binary tree from a given traversal, such as pre-order or post-order. This can be done using recursive algorithms or stack-based approaches.</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c27 c13 c21"><span class="c23">Constructing a tree from traversal refers to the process of constructing a binary tree from its pre-order or post-order traversal.</span></p><p class="c27 c13 c21"><span class="c23">In pre-order traversal, the root node is visited first, then the left subtree, and then the right subtree. In post-order traversal, the left subtree is visited first, then the right subtree, and then the root node.</span></p><p class="c27 c13 c21"><span class="c23">To construct a binary tree from its pre-order traversal, we follow these steps:</span></p><ol class="c14 lst-kix_613sjpguxhc3-0 start" start="1"><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Create a new node with the value of the first element of the pre-order traversal.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Find the index of the first element in the pre-order traversal that is greater than the value of the root node. This will be the index of the first element in the right subtree.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Recursively construct the left subtree using the elements of the pre-order traversal up to the index found in step 2.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Recursively construct the right subtree using the elements of the pre-order traversal from the index found in step 2 to the end of the traversal.</span></li></ol><p class="c27 c13 c21"><span class="c23">Similarly, to construct a binary tree from its post-order traversal, we follow these steps:</span></p><ol class="c14 lst-kix_7z09ch6fo6gp-0 start" start="1"><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Create a new node with the value of the last element of the post-order traversal.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Find the index of the last element in the post-order traversal that is less than the value of the root node. This will be the index of the last element in the left subtree.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Recursively construct the right subtree using the elements of the post-order traversal from the index found in step 2 to the second-to-last element.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Recursively construct the left subtree using the elements of the post-order traversal from the beginning of the traversal to the index found in step 2.</span></li></ol><p class="c27 c13 c21"><span class="c23">Here&#39;s an example C program that constructs a binary tree from its pre-order traversal:</span></p><p class="c13"><span class="c8">#include &lt;stdio.h&gt;</span></p><p class="c13"><span class="c8">#include &lt;stdlib.h&gt;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">typedef struct Node {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; int data;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; struct Node* left;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; struct Node* right;</span></p><p class="c13"><span class="c8">} Node;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">Node* construct_tree_from_preorder(int pre[], int size) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; if (size == 0) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; return NULL;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; Node* root = (Node*) malloc(sizeof(Node));</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; root-&gt;data = pre[0];</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; int index = 1;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; while (index &lt; size &amp;&amp; pre[index] &lt; root-&gt;data) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; index++;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; root-&gt;left = construct_tree_from_preorder(pre+1, index-1);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; root-&gt;right = construct_tree_from_preorder(pre+index, size-index);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; return root;</span></p><p class="c13"><span class="c8">}</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">void inorder_traversal(Node* root) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; if (root != NULL) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; inorder_traversal(root-&gt;left);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%d &quot;, root-&gt;data);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; inorder_traversal(root-&gt;right);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c8">}</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">int main() {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; int pre[] = {10, 5, 3, 8, 15, 12, 18};</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; int size = sizeof(pre) / sizeof(pre[0]);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; Node* root = construct_tree_from_preorder(pre, size);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; printf(&quot;In-order traversal: &quot;);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; inorder_traversal(root);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; printf(&quot;\n&quot;);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; return 0;</span></p><p class="c13"><span class="c8">}</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c19">This program constructs a binary tree from the pre-order traversal </span><span class="c37 c21">{10, 5, 3, 8, 15, 12, 18}</span><span class="c23 c21">&nbsp;and performs an in-order traversal to print the values of the nodes in the tree. The output of the program is:</span></p><p class="c13"><span class="c23 c21">In-order traversal: 3 5 8 10 12 15 18</span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13 c26"><span class="c11"></span></p>
               
               </fieldset>
           <fieldset class="topic-card">
               
               <p class="c13"><span class="topics">Warshall and Dijkstra algorithms:</span>
               
               
               
               
               <span class="c11">&nbsp;These are two algorithms commonly used in graph theory. Warshall&#39;s algorithm is used to compute the transitive closure of a directed graph, while Dijkstra&#39;s algorithm is used to find the shortest path between two nodes in a weighted graph.</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c13"><span class="c23">Warshall Algorithm:</span></p><p class="c27 c13 c21"><span class="c23">The Warshall Algorithm is used to find the transitive closure of a given directed graph. It is based on dynamic programming and is very efficient for small to medium-sized graphs.</span></p><p class="c27 c13 c21"><span class="c23">C Program for Warshall Algorithm:</span></p><p class="c17"><span class="c34">#include&lt;stdio.h&gt;</span></p><p class="c17"><span class="c34">#include&lt;stdlib.h&gt;</span></p><p class="c17 c26"><span class="c34"></span></p><p class="c17"><span class="c34">int main() {</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; int i,j,k,n;</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; printf(&quot;Enter the number of vertices: &quot;);</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; scanf(&quot;%d&quot;,&amp;n);</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; int graph[n][n];</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; printf(&quot;Enter the adjacency matrix: &quot;);</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; for(i=0;i&lt;n;i++) {</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; for(j=0;j&lt;n;j++) {</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; scanf(&quot;%d&quot;,&amp;graph[i][j]);</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; }</span></p><p class="c17 c26"><span class="c34"></span></p><p class="c17"><span class="c34">&nbsp; &nbsp; for(k=0;k&lt;n;k++) {</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; for(i=0;i&lt;n;i++) {</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for(j=0;j&lt;n;j++) {</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; graph[i][j] = graph[i][j] || (graph[i][k] &amp;&amp; graph[k][j]);</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; }</span></p><p class="c17 c26"><span class="c34"></span></p><p class="c17"><span class="c34">&nbsp; &nbsp; printf(&quot;The transitive closure of the given graph is:\n&quot;);</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; for(i=0;i&lt;n;i++) {</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; for(j=0;j&lt;n;j++) {</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%d &quot;,graph[i][j]);</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;\n&quot;);</span></p><p class="c17"><span class="c34">&nbsp; &nbsp; }</span></p><p class="c17 c26"><span class="c34"></span></p><p class="c17"><span class="c34">&nbsp; &nbsp; return 0;</span></p><p class="c17"><span class="c34">}</span></p><p class="c17 c26"><span class="c34"></span></p><p class="c27 c17 c21"><span class="c12">Example:</span></p><p class="c27 c17 c21"><span class="c12">Consider the following graph with 4 vertices.</span></p><p class="c17"><span class="c34">0 --&gt; 1 --&gt; 2</span></p><p class="c17"><span class="c34">^ &nbsp; &nbsp; |</span></p><p class="c17"><span class="c34">| &nbsp; &nbsp; v</span></p><p class="c17"><span class="c34">3 &lt;-- 4</span></p><p class="c17 c26"><span class="c34"></span></p><p class="c17"><span class="c12">The adjacency matrix for this graph is:</span></p><p class="c17"><span class="c12">0 1 1 0 0</span></p><p class="c17"><span class="c12">0 0 1 0 0</span></p><p class="c17"><span class="c12">0 0 0 0 1</span></p><p class="c17"><span class="c12">1 0 0 0 1</span></p><p class="c17"><span class="c12">0 0 0 1 0</span></p><p class="c17 c26"><span class="c12"></span></p><p class="c27 c17 c21"><span class="c12">Using Warshall Algorithm, we can find the transitive closure of the given graph as:</span></p><p class="c17"><span class="c12">1 1 1 1 1</span></p><p class="c17"><span class="c12">0 1 1 0 0</span></p><p class="c17"><span class="c12">0 0 0 0 1</span></p><p class="c17"><span class="c12">1 1 1 1 1</span></p><p class="c17"><span class="c12">0 0 0 1 0</span></p><p class="c17 c26"><span class="c23 c21"></span></p><p class="c17"><span class="c23 c21">Dijkstra Algorithm:</span></p><p class="c27 c17 c21"><span class="c23 c21">The Dijkstra Algorithm is used to find the shortest path between two nodes in a graph. It is based on the concept of a priority queue and is very efficient for small to medium-sized graphs.</span></p><p class="c27 c17 c21"><span class="c23 c21">C Program for Dijkstra Algorithm:</span></p><p class="c17"><span class="c12">#include&lt;stdio.h&gt;</span></p><p class="c17"><span class="c12">#include&lt;stdlib.h&gt;</span></p><p class="c17"><span class="c12">#include&lt;limits.h&gt;</span></p><p class="c17 c26"><span class="c12"></span></p><p class="c17"><span class="c12">int minDistance(int dist[], int sptSet[], int n) {</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; int min = INT_MAX, min_index;</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; for(int v=0;v&lt;n;v++) {</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; if(sptSet[v]==0 &amp;&amp; dist[v]&lt;=min) {</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min = dist[v];</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; min_index = v;</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; }</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; return min_index;</span></p><p class="c17"><span class="c12">}</span></p><p class="c17 c26"><span class="c12"></span></p><p class="c17"><span class="c12">void dijkstra(int graph[][5], int src, int n) {</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; int dist[n], sptSet[n], parent[n];</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; for(int i=0;i&lt;n;i++) {</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; dist[i] = INT_MAX;</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; sptSet[i] = 0;</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; parent[i] = -1;</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; }</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; dist[src] = 0;</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; for(int count=0;count&lt;n-1;count++) {</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; int u = minDistance(dist,sptSet,n);</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; sptSet[u] = 1;</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; for(int v=0;v&lt;n;v++) {</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(!sptSet[v] &amp;&amp; graph[u][v] &amp;&amp; dist[u]!=INT_MAX &amp;&amp; dist[u]+graph[u][v]&lt;dist[v]) {</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; dist[v] = dist[u] + graph[u][v];</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent[v] = u;</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; }</span></p><p class="c17 c26"><span class="c12"></span></p><p class="c17"><span class="c12">&nbsp; &nbsp; printf(&quot;Vertex\tDistance\tPath\n&quot;);</span></p><p class="c17"><span class="c12">&nbsp; &nbsp; for(int</span></p><p class="c17 c26"><span class="c12"></span></p><p class="c17 c26"><span class="c12"></span></p><p class="c13 c26"><span class="c11"></span></p><p class="c13 c26"><span class="c11"></span></p>
               
               </fieldset>
           <fieldset class="topic-card">
               
               <p class="c13"><span class="topics">Distance calculation:</span>
               
               
               
               <span class="c11">&nbsp;This refers to calculating the distance between two points in a graph or geometric space, which can be done using various mathematical formulas.</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c27 c13 c21"><span class="c23">To calculate the distance between two points in a geometric space, we can use the distance formula:</span></p><p class="c27 c13 c21"><span class="c23">d = sqrt((x2-x1)^2 + (y2-y1)^2)</span></p><p class="c27 c13 c21"><span class="c23">where (x1, y1) and (x2, y2) are the coordinates of the two points and d is the distance between them.</span></p><p class="c27 c13 c21"><span class="c23">Here&#39;s an example C program that calculates the distance between two points:</span></p><p class="c13"><span class="c8">#include &lt;stdio.h&gt;</span></p><p class="c13"><span class="c8">#include &lt;math.h&gt;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">int main() {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; float x1, y1, x2, y2, distance;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; </span></p><p class="c13"><span class="c8">&nbsp; &nbsp; printf(&quot;Enter the coordinates of point 1: &quot;);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; scanf(&quot;%f %f&quot;, &amp;x1, &amp;y1);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; </span></p><p class="c13"><span class="c8">&nbsp; &nbsp; printf(&quot;Enter the coordinates of point 2: &quot;);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; scanf(&quot;%f %f&quot;, &amp;x2, &amp;y2);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; </span></p><p class="c13"><span class="c8">&nbsp; &nbsp; distance = sqrt(pow((x2-x1), 2) + pow((y2-y1), 2));</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; </span></p><p class="c13"><span class="c8">&nbsp; &nbsp; printf(&quot;The distance between the two points is %.2f\n&quot;, distance);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; </span></p><p class="c13"><span class="c8">&nbsp; &nbsp; return 0;</span></p><p class="c13"><span class="c8">}</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c27 c13 c21"><span class="c35">In this program, we first prompt the user to enter the coordinates of the two points. We then use the distance formula to calculate the distance between the two points and store it in the </span><span class="c22">distance</span><span class="c35">&nbsp;variable. Finally, we print the result to the console using </span><span class="c22">printf</span><span class="c23">.</span></p><p class="c27 c13 c21"><span class="c23">Here&#39;s an example output of the program:</span></p><p class="c13"><span class="c11">Enter the coordinates of point 1: 1 2</span></p><p class="c13"><span class="c11">Enter the coordinates of point 2: 4 6</span></p><p class="c13"><span class="c11">The distance between the two points is 5.00</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c13 c26"><span class="c11"></span></p>
               
               
               </fieldset>
           <fieldset class="topic-card">

               <p class="c13"><span class="topics">Minimum spanning tree:</span>
               
               
               <span class="c11">&nbsp;This is a subset of edges in a connected, weighted graph that connects all the vertices with the minimum possible total edge weight.</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c27 c13 c21"><span class="c23">A minimum spanning tree (MST) is a tree that connects all vertices of an undirected graph with the minimum possible total edge weight. In other words, it is a subset of the edges that form a tree connecting all vertices together while minimizing the total edge weight.</span></p><p class="c27 c13 c21"><span class="c23">There are different algorithms for finding the minimum spanning tree of a graph, including:</span></p><ol class="c14 lst-kix_ya30qoff27qw-0 start" start="1"><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Kruskal&#39;s algorithm: This algorithm starts with an empty set of edges and gradually adds edges to the set in increasing order of their weights, as long as adding an edge does not create a cycle.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Prim&#39;s algorithm: This algorithm starts with an arbitrary vertex and adds the minimum weight edge connecting the tree to a non-tree vertex at each step, until all vertices are in the tree.</span></li></ol><p class="c13 c26"><span class="c11"></span></p><p class="c13 c26"><span class="c11"></span></p>
               
               
               </fieldset>
           <fieldset class="topic-card">

               <p class="c13"><span class="topics">Prim and Kruskal algorithms:</span>
               
               
               
               <span class="c11">&nbsp;These are two algorithms commonly used to find the minimum spanning tree of a graph. Prim&#39;s algorithm starts at a single vertex and adds edges to the tree that minimize the total weight, while Kruskal&#39;s algorithm builds the tree by adding edges in increasing order of weight until all vertices are connected.</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c27 c13 c21"><span class="c23">Prim&#39;s algorithm is a greedy algorithm used to find the minimum spanning tree of a weighted undirected graph. The algorithm starts with an arbitrary vertex and grows the tree by adding the nearest vertex until all vertices are included in the tree.</span></p><p class="c27 c13 c21"><span class="c23">Here&#39;s an example C++ code for Prim&#39;s algorithm:</span></p><p class="c13"><span class="c8">#include&lt;bits/stdc++.h&gt;</span></p><p class="c13"><span class="c8">using namespace std;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">const int INF = 1e9;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">int main() {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; int n, m;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; cin &gt;&gt; n &gt;&gt; m;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; vector&lt;pair&lt;int, int&gt;&gt; adj[n];</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; for(int i = 0; i &lt; m; i++) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; int u, v, w;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; adj[u-1].push_back({v-1, w});</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; adj[v-1].push_back({u-1, w});</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; int src = 0; // starting vertex</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; vector&lt;int&gt; key(n, INF);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; vector&lt;bool&gt; mst(n, false);</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; vector&lt;int&gt; parent(n, -1);</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; priority_queue&lt;pair&lt;int, int&gt;, vector&lt;pair&lt;int, int&gt;&gt;, greater&lt;pair&lt;int, int&gt;&gt;&gt; pq;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; pq.push({0, src});</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; key[src] = 0;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; while(!pq.empty()) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; int u = pq.top().second;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; pq.pop();</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; mst[u] = true;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; for(auto it : adj[u]) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int v = it.first;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int w = it.second;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if(!mst[v] &amp;&amp; w &lt; key[v]) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; parent[v] = u;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; key[v] = w;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; pq.push({key[v], v});</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; int cost = 0;</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; for(int i = 1; i &lt; n; i++) {</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; cost += key[i];</span></p><p class="c13"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; cout &lt;&lt; cost &lt;&lt; endl;</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c13"><span class="c8">&nbsp; &nbsp; return 0;</span></p><p class="c13"><span class="c8">}</span></p><p class="c13 c26"><span class="c8"></span></p><p class="c27 c13 c21"><span class="c23">In this code, we first input the number of vertices and edges of the graph. Then we create an adjacency list to represent the graph. Next, we initialize the key, mst, and parent vectors, and a priority queue to hold the vertices in order of increasing key values. We push the starting vertex into the queue with a key value of 0.</span></p><p class="c27 c13 c21"><span class="c23">In the main loop of the algorithm, we pop the vertex with the smallest key value from the queue, mark it as visited, and update the key values and parent vectors for its neighbors if necessary. We continue this process until all vertices are visited.</span></p><p class="c27 c13 c21"><span class="c23">Finally, we calculate the cost of the minimum spanning tree by summing up the key values of all vertices except the starting vertex, and output it.</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c13 c26"><span class="c11"></span></p><p class="c27 c13 c21"><span class="c23">Here is an example C++ code for Kruskal&#39;s algorithm:</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c13"><span class="c1">#include &lt;iostream&gt;</span></p><p class="c13"><span class="c1">#include &lt;vector&gt;</span></p><p class="c13"><span class="c1">#include &lt;algorithm&gt;</span></p><p class="c13 c26"><span class="c1"></span></p><p class="c13"><span class="c1">using namespace std;</span></p><p class="c13 c26"><span class="c1"></span></p><p class="c13"><span class="c1">class Edge {</span></p><p class="c13"><span class="c1">public:</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; int src, dest, weight;</span></p><p class="c13"><span class="c1">};</span></p><p class="c13 c26"><span class="c1"></span></p><p class="c13"><span class="c1">class Graph {</span></p><p class="c13"><span class="c1">public:</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; int V, E;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; vector&lt;Edge&gt; edges;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; Graph(int v, int e) {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; V = v;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; E = e;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; edges.resize(E);</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c1">};</span></p><p class="c13 c26"><span class="c1"></span></p><p class="c13"><span class="c1">class Subset {</span></p><p class="c13"><span class="c1">public:</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; int parent, rank;</span></p><p class="c13"><span class="c1">};</span></p><p class="c13 c26"><span class="c1"></span></p><p class="c13"><span class="c1">int find(Subset subsets[], int i) {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; if (subsets[i].parent != i) {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; subsets[i].parent = find(subsets, subsets[i].parent);</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; return subsets[i].parent;</span></p><p class="c13"><span class="c1">}</span></p><p class="c13 c26"><span class="c1"></span></p><p class="c13"><span class="c1">void Union(Subset subsets[], int x, int y) {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; int xroot = find(subsets, x);</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; int yroot = find(subsets, y);</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; if (subsets[xroot].rank &lt; subsets[yroot].rank) {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; subsets[xroot].parent = yroot;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; else if (subsets[xroot].rank &gt; subsets[yroot].rank) {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; subsets[yroot].parent = xroot;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; else {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; subsets[yroot].parent = xroot;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; subsets[xroot].rank++;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c1">}</span></p><p class="c13 c26"><span class="c1"></span></p><p class="c13"><span class="c1">bool myComp(Edge a, Edge b) {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; return a.weight &lt; b.weight;</span></p><p class="c13"><span class="c1">}</span></p><p class="c13 c26"><span class="c1"></span></p><p class="c13"><span class="c1">void kruskalMST(Graph graph) {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; int V = graph.V;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; Edge result[V];</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; int e = 0, i = 0;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; sort(graph.edges.begin(), graph.edges.end(), myComp);</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; Subset *subsets = new Subset[V];</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; for (int v = 0; v &lt; V; v++) {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; subsets[v].parent = v;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; subsets[v].rank = 0;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; while (e &lt; V - 1 &amp;&amp; i &lt; graph.E) {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; Edge next_edge = graph.edges[i++];</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; int x = find(subsets, next_edge.src);</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; int y = find(subsets, next_edge.dest);</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; if (x != y) {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; result[e++] = next_edge;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Union(subsets, x, y);</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; cout &lt;&lt; &quot;Minimum Spanning Tree:&quot; &lt;&lt; endl;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; for (i = 0; i &lt; e; i++) {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; result[i].src &lt;&lt; &quot; - &quot; &lt;&lt; result[i].dest &lt;&lt; &quot; : &quot; &lt;&lt; result[i].weight &lt;&lt; endl;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; return;</span></p><p class="c13"><span class="c1">}</span></p><p class="c13 c26"><span class="c1"></span></p><p class="c13"><span class="c1">int main() {</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; int V = 4;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; int E = 5;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; Graph graph(V, E);</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[0].src = 0;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[0].dest = 1;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[0].weight = 10;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[1].src = 0;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[1].dest = 2;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[1].weight = 6;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[2].src = 0;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[2].dest = 3;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[2].weight = 5;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[3].src = 1;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[3].dest = 3;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[3].weight = 15;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[4].src = 2;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[4].dest = 3;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; graph.edges[4].weight = 4;</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; kruskalMST(graph);</span></p><p class="c13"><span class="c1">&nbsp; &nbsp; return 0;</span></p><p class="c13"><span class="c1">}</span></p><p class="c13 c26"><span class="c44 topics"></span></p><p class="c13 c26"><span class="c44 topics"></span></p>
               

               </fieldset>
           <fieldset class="topic-card">
               
               <p class="c13"><span class="topics">Huffman coding:</span>
               
               
               <span class="c11">&nbsp;This is a data compression algorithm that uses variable-length codes to represent different characters or symbols in a message, with more frequently occurring symbols assigned shorter codes. This can result in significant compression of data while still allowing for efficient decoding.</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c27 c13 c21"><span class="c23">Huffman coding is a lossless data compression technique used for compressing data by assigning variable-length codes to individual symbols based on their frequency of occurrence in the input data. The more frequently occurring symbols are assigned shorter codes and less frequently occurring symbols are assigned longer codes. This reduces the amount of space required to store the data, thus allowing for faster transmission and storage.</span></p><p class="c27 c13 c21"><span class="c23">The Huffman coding algorithm involves the following steps:</span></p><ol class="c14 lst-kix_9zyhscp7gdla-0 start" start="1"><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Count the frequency of each symbol in the input data.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Sort the symbols in ascending order of frequency.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Create a binary tree with the symbols as the leaf nodes and their frequencies as the weights of the nodes.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Combine the two nodes with the lowest weights to form a new internal node with a weight equal to the sum of the weights of the two nodes.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Repeat step 4 until all the nodes are combined into a single root node.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Assign a 0 to each left branch and a 1 to each right branch.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Traverse the tree and assign the corresponding codes to each symbol.</span></li><li class="c27 c13 c6 c21 li-bullet-0"><span class="c23">Compress the input data by replacing each symbol with its corresponding code.</span></li></ol><p class="c27 c13 c21"><span class="c23">Here is an example implementation of the Huffman coding algorithm in C++:</span></p><p class="c13"><span class="c11 c30">#include &lt;iostream&gt;</span></p><p class="c13"><span class="c11 c30">#include &lt;queue&gt;</span></p><p class="c13"><span class="c11 c30">#include &lt;unordered_map&gt;</span></p><p class="c13"><span class="c11 c30">#include &lt;string&gt;</span></p><p class="c13"><span class="c11 c30">#include &lt;bitset&gt;</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">using namespace std;</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">// A Huffman tree node</span></p><p class="c13"><span class="c11 c30">struct Node {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; char ch;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; int freq;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; Node *left, *right;</span></p><p class="c13"><span class="c11 c30">};</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">// Function to create a new Huffman tree node</span></p><p class="c13"><span class="c11 c30">Node* newNode(char ch, int freq, Node* left = nullptr, Node* right = nullptr) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; Node* node = new Node;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; node-&gt;ch = ch;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; node-&gt;freq = freq;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; node-&gt;left = left;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; node-&gt;right = right;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; return node;</span></p><p class="c13"><span class="c11 c30">}</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">// Function to compare two nodes based on their frequency</span></p><p class="c13"><span class="c11 c30">struct comp {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; bool operator()(Node* left, Node* right) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; return left-&gt;freq &gt; right-&gt;freq;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c11 c30">};</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">// Function to build a Huffman tree from the given characters and their frequencies</span></p><p class="c13"><span class="c11 c30">Node* buildHuffmanTree(const string&amp; text) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; // Count the frequency of each character</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; unordered_map&lt;char, int&gt; freq;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; for (char ch : text) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; freq[ch]++;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; }</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; // Create a priority queue to store the nodes with the minimum frequency at the top</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; priority_queue&lt;Node*, vector&lt;Node*&gt;, comp&gt; pq;</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; // Create a leaf node for each character and add it to the priority queue</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; for (auto it = freq.begin(); it != freq.end(); it++) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; pq.push(newNode(it-&gt;first, it-&gt;second));</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; }</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; // Combine the nodes with the minimum frequency to form a new internal node until there is only one node left in the priority queue</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; while (pq.size() != 1) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; Node* left = pq.top();</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; pq.pop();</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; Node* right = pq.top();</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; pq.pop();</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; Node* internal = newNode(&#39;\0&#39;, left-&gt;freq + right-&gt;freq, left, right);</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; pq.push(internal);</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; }</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; // The remaining node is the root of the Huffman tree</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; return pq.top();</span></p><p class="c13"><span class="c11 c30">}</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">// Function to traverse the Huffman tree and generate the Huffman codes for each character</span></p><p class="c13"><span class="c11 c30">void generateCodes(Node* node, string code, unordered_map&lt;char, string&gt;&amp; codes) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; if (!node) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; return;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; if (node-&gt;ch != &#39;\0&#39;) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; codes[node-&gt;ch] = code;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; generateCodes(node-&gt;left, code + &quot;0&quot;, codes);</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; generateCodes(node-&gt;right, code + &quot;1&quot;, codes);</span></p><p class="c13"><span class="c11 c30">}</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">// Function to compress the input text using the Huffman codes</span></p><p class="c13"><span class="c11 c30">string compress(const string&amp; text) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; // Build the Huffman tree and generate the Huffman codes for each character</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; Node* root = buildHuffmanTree(text);</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; unordered_map&lt;char, string&gt; codes;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; generateCodes(root, &quot;&quot;, codes);</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; // Encode the input text using the Huffman codes</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; string encoded = &quot;&quot;;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; for (char ch : text) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; encoded += codes[ch];</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; }</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; // Pad the encoded string with zeros to ensure its length is a multiple of 8</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; while (encoded.length() % 8 != 0) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; encoded += &quot;0&quot;;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; }</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; // Convert the encoded string to a bitset and pack it into bytes</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; string packed = &quot;&quot;;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; bitset&lt;8&gt; byte;</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; for (int i = 0; i &lt; encoded.length(); i++) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; byte[i % 8] = (encoded[i] == &#39;1&#39;);</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; if (i % 8 == 7) {</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; packed += (char) byte.to_ulong();</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; }</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">&nbsp; &nbsp; return packed;</span></p><p class="c13"><span class="c11 c30">}</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c11 c30">// Function to decompress the input text using the Huffman</span></p><p class="c13 c26"><span class="c11 c30"></span></p><p class="c13"><span class="c23 c30">// codes and the Huffman tree</span></p><p class="c13"><span class="c23 c30">string decompress(const string&amp; text, Node* root) {</span></p><p class="c13"><span class="c23 c30">string result;</span></p><p class="c13"><span class="c23 c30">Node* curr = root;</span></p><p class="c13"><span class="c23 c30">for (char ch : text) {</span></p><p class="c13"><span class="c23 c30">if (ch == &#39;0&#39;) {</span></p><p class="c13"><span class="c23 c30">curr = curr-&gt;left;</span></p><p class="c13"><span class="c23 c30">} else {</span></p><p class="c13"><span class="c23 c30">curr = curr-&gt;right;</span></p><p class="c13"><span class="c23 c30">}</span></p><p class="c13"><span class="c23 c30">if (curr-&gt;ch != &#39;\0&#39;) {</span></p><p class="c13"><span class="c23 c30">result += curr-&gt;ch;</span></p><p class="c13"><span class="c23 c30">curr = root;</span></p><p class="c13"><span class="c23 c30">}</span></p><p class="c13"><span class="c23 c30">}</span></p><p class="c13"><span class="c23 c30">return result;</span></p><p class="c27 c13 c21"><span class="c23 c30">}</span></p><p class="c13"><span class="c23 c30">int main() {</span></p><p class="c13"><span class="c23 c30">string text = &quot;hello world&quot;;</span></p><p class="c13"><span class="c23 c30">Node* root = buildHuffmanTree(text);</span></p><p class="c13"><span class="c23 c30">unordered_map&lt;char, string&gt; codes;</span></p><p class="c13"><span class="c23 c30">generateCodes(root, &quot;&quot;, codes);</span></p><p class="c13"><span class="c23 c30">string encodedText = compress(text, codes);</span></p><p class="c13"><span class="c23 c30">string decodedText = decompress(encodedText, root);</span></p><p class="c13"><span class="c23 c30">cout &lt;&lt; &quot;Original text: &quot; &lt;&lt; text &lt;&lt; endl;</span></p><p class="c13"><span class="c23 c30">cout &lt;&lt; &quot;Encoded text: &quot; &lt;&lt; encodedText &lt;&lt; endl;</span></p><p class="c13"><span class="c23 c30">cout &lt;&lt; &quot;Decoded text: &quot; &lt;&lt; decodedText &lt;&lt; endl;</span></p><p class="c13"><span class="c23 c30">return 0;</span></p><p class="c27 c13 c21"><span class="c23 c30">}</span></p><p class="c13 c26"><span class="c11"></span></p><p class="c4">
                   
                   </fieldset>
           <fieldset class="topic-card">
                   
                   <span class="topics">AVL tree:</span>
                   
                   
                   <span class="c11">&nbsp;This is a self-balancing binary search tree, where the heights of the left and right subtrees of any node differ by at most one. This ensures that the tree remains balanced, which results in efficient searching, insertion, and deletion operations.</span></p><p class="c4 c21"><span class="c23">AVL tree is a self-balancing binary search tree, where the heights of the left and right subtrees of every node differ by at most one. It was named after its inventors Adelson-Velsky and Landis. AVL tree is a special type of binary search tree which provides faster operations than a normal binary search tree, as it ensures the tree remains balanced.</span></p><p class="c4 c21"><span class="c23">The AVL tree has the following properties:</span></p><ol class="c14 lst-kix_bisdh8len5xz-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c23">The height of the left and right subtrees of every node differs by at most one.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Every subtree is an AVL tree.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Every node stores an extra value called balance factor, which is calculated as the difference between the height of the left subtree and the height of the right subtree. The balance factor can be -1, 0, or 1.</span></li></ol><p class="c4 c21"><span class="c23">AVL tree supports all the basic operations of a binary search tree such as searching, insertion, and deletion. When a node is inserted or deleted, if the balance factor of any node becomes -2 or 2, the tree is rebalanced. There are four types of rotations used in AVL trees to balance the tree:</span></p><ol class="c14 lst-kix_jkixku10wike-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c23">Left rotation: This is used to balance a node with a balance factor of 2 and its right subtree having a balance factor of -1 or 0.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Right rotation: This is used to balance a node with a balance factor of -2 and its left subtree having a balance factor of 1 or 0.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Left-Right rotation: This is used to balance a node with a balance factor of 2 and its right subtree having a balance factor of 1.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Right-Left rotation: This is used to balance a node with a balance factor of -2 and its left subtree having a balance factor of -1.</span></li></ol><p class="c4 c21"><span class="c23">Here is an example implementation of an AVL tree in C++:</span></p><p class="c4"><span class="c7">#include &lt;iostream&gt;</span></p><p class="c4"><span class="c7">#include &lt;algorithm&gt;</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">using namespace std;</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">// AVL tree node</span></p><p class="c4"><span class="c7">struct Node {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; int value;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; int height;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; Node* left;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; Node* right;</span></p><p class="c4"><span class="c7">};</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">// Function to get the height of a node</span></p><p class="c4"><span class="c7">int height(Node* node) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; if (node == nullptr) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; return 0;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; return node-&gt;height;</span></p><p class="c4"><span class="c7">}</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">// Function to get the balance factor of a node</span></p><p class="c4"><span class="c7">int balance(Node* node) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; if (node == nullptr) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; return 0;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; return height(node-&gt;left) - height(node-&gt;right);</span></p><p class="c4"><span class="c7">}</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">// Function to create a new AVL tree node</span></p><p class="c4"><span class="c7">Node* newNode(int value) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; Node* node = new Node;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; node-&gt;value = value;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; node-&gt;height = 1;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; node-&gt;left = nullptr;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; node-&gt;right = nullptr;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; return node;</span></p><p class="c4"><span class="c7">}</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">// Function to right rotate the subtree rooted at y</span></p><p class="c4"><span class="c7">Node* rotateRight(Node* y) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; Node* x = y-&gt;left;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; Node* T2 = x-&gt;right;</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Perform rotation</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; x-&gt;right = y;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; y-&gt;left = T2;</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Update heights</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + 1;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + 1;</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Return new root</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; return x;</span></p><p class="c4"><span class="c7">}</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">// Function to left rotate the subtree rooted at x</span></p><p class="c4"><span class="c7">Node* rotateLeft(Node* x) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; Node* y = x-&gt;right;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; Node* T2 = y-&gt;left;</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Perform rotation</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; y-&gt;left = x;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; x-&gt;right = T2;</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Update heights</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; x-&gt;height = max(height(x-&gt;left), height(x-&gt;right)) + 1;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; y-&gt;height = max(height(y-&gt;left), height(y-&gt;right)) + 1;</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Return new root</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; return y;</span></p><p class="c4"><span class="c7">}</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">// Function to insert a value into the AVL tree</span></p><p class="c4"><span class="c7">Node* insert(Node* node, int value) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Perform the normal BST insertion</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; if (node == nullptr) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; return newNode(value);</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; if (value &lt; node-&gt;value) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;left = insert(node-&gt;left, value);</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; } else if (value &gt; node-&gt;value) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;right = insert(node-&gt;right, value);</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; } else {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; return node;</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; }</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Update the height of the current node</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; node-&gt;height = 1 + max(height(node-&gt;left), height(node-&gt;right));</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Get the balance factor of the current node</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; int balanceFactor = balance(node);</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Left Left Case</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; if (balanceFactor &gt; 1 &amp;&amp; value &lt; node-&gt;left-&gt;value) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; return rotateRight(node);</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; }</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Right Right Case</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; if (balanceFactor &lt; -1 &amp;&amp; value &gt; node-&gt;right-&gt;value) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; return rotateLeft(node);</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; }</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Left Right Case</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; if (balanceFactor &gt; 1 &amp;&amp; value &gt; node-&gt;left-&gt;value) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;left = rotateLeft(node-&gt;left);</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; return rotateRight(node);</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; }</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Right Left Case</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; if (balanceFactor &lt; -1 &amp;&amp; value &lt; node-&gt;right-&gt;value) {</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; node-&gt;right = rotateRight(node-&gt;right);</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; &nbsp; &nbsp; return rotateLeft(node);</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; }</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">&nbsp; &nbsp; // Return the unchanged node</span></p><p class="c4"><span class="c7">&nbsp; &nbsp; return node;</span></p><p class="c4"><span class="c7">}</span></p><p class="c3"><span class="c7"></span></p><p class="c4"><span class="c7">// Function to print the AVL tree in order</span></p><p class="c4"><span class="c38">// Function to print an AVL tree in order</span></p><p class="c4"><span class="c38">void</span><span class="c38">&nbsp;</span><span class="c38">printInOrder</span><span class="c32">(Node* node) {</span></p><p class="c4"><span class="c38">&nbsp; &nbsp; </span><span class="c38">if</span><span class="c38">&nbsp;(node == </span><span class="c38">nullptr</span><span class="c32">) {</span></p><p class="c4"><span class="c38">&nbsp; &nbsp; &nbsp; &nbsp; </span><span class="c38">return</span><span class="c32">;</span></p><p class="c4"><span class="c32">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c38">&nbsp; &nbsp; </span><span class="c38">printInOrder</span><span class="c32">(node-&gt;left);</span></p><p class="c4"><span class="c38">&nbsp; &nbsp; cout &lt;&lt; node-&gt;key &lt;&lt; </span><span class="c38">&quot;</span></p><p class="c3"><span class="c11"></span></p><p class="c4">
                       
                       
</fieldset>
           <fieldset class="topic-card">

                       <span class="topics">B-tree:</span>
                       
                       
                       
                       <span class="c11">&nbsp;This is a self-balancing tree data structure that allows for efficient storage and retrieval of large amounts of data. B-trees are commonly used in databases and file systems, where they allow for efficient indexing and searching of data.</span></p><p class="c4"><span class="c11">B-tree is a self-balancing tree data structure that is commonly used for storing large amounts of data on secondary storage such as hard drives. It is designed to reduce the number of disk accesses required to find a particular record in the tree. In a B-tree, each node can contain multiple keys and child nodes. The number of keys in each node is usually between a minimum and maximum value, which is fixed for a particular B-tree.</span></p><p class="c4"><span class="c11">The keys in a B-tree are stored in sorted order, and each internal node of the tree acts as an index to the keys in its child nodes. The child nodes are themselves B-trees, and the depth of the tree is kept small by ensuring that each node contains a large number of keys.</span></p><p class="c4"><span class="c11">The insertion and deletion operations in a B-tree involve splitting and merging nodes to maintain the balance of the tree. This ensures that the height of the tree remains small, which in turn reduces the number of disk accesses required to find a particular record.</span></p><p class="c4"><span class="c11">Here&#39;s an example of a B-tree of order 3:</span></p><p class="c17 c27"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; [F, K]</span></p><p class="c27 c17"><span class="c25">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;/ &nbsp; &nbsp; &nbsp; &nbsp;\</span></p><p class="c27 c17"><span class="c25">&nbsp; &nbsp; &nbsp;[A, C, D] &nbsp; &nbsp;[M, P, R, S]</span></p><p class="c27 c17"><span class="c25">&nbsp; &nbsp; / &nbsp; | &nbsp; \ &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;| &nbsp; &nbsp;\</span></p><p class="c27 c17"><span class="c25">&nbsp; &nbsp;* &nbsp; &nbsp;* &nbsp; &nbsp;* &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; * &nbsp; &nbsp; *</span></p><p class="c27 c17 c26"><span class="c25"></span></p><p class="c27 c17 c26"><span class="c25"></span></p><p class="c27 c17"><span class="c40">[F, K]</span><span class="c42">&nbsp;/ \ </span><span class="c40">[A, C, D]</span><span class="c42">&nbsp;</span><span class="c40">[M, P, R, S]</span><span class="c42 c45">&nbsp;/ | \ | \ * * * * *</span></p><p class="c4"><span class="c11">In this example, each node can contain up to 3 keys, and the child nodes are either leaf nodes (represented by *) or internal nodes (represented by brackets).</span></p><p class="c4"><span class="c11">To search for a key in a B-tree, we start at the root node and compare the key to be searched with the keys in the node. If the key is found, we return the node containing the key. Otherwise, we follow the child node corresponding to the range in which the key may lie and repeat the process until we reach a leaf node.</span></p><p class="c4"><span class="c11">Similarly, to insert a key into a B-tree, we start at the root node and follow the path to the leaf node where the key should be inserted. If the leaf node has space for the key, we insert it there. Otherwise, we split the node and redistribute the keys between the two new nodes.</span></p><p class="c4"><span class="c11">Deletion of a key from a B-tree is a more complicated operation, and involves redistributing keys between nodes and possibly merging nodes to maintain the balance of the tree.</span></p><p class="c3"><span class="c11"></span></p><p class="c3"><span class="c11"></span></p><p class="c4">
                           
                          </fieldset>
           <fieldset class="topic-card"> 
                           
                           <span class="topics">DFS and BFS:</span>
                           
                           
                           
                           <span class="c11">&nbsp;These are two algorithms used for traversing graphs. DFS (depth-first search) visits all the nodes of a graph in depth-first order, while BFS (breadth-first search) visits all the nodes at a given depth before moving on to the next level.</span></p><p class="c4 c21"><span class="c23">DFS (Depth First Search) and BFS (Breadth First Search) are two common graph traversal algorithms. They are used to visit all the vertices or nodes in a graph or tree.</span></p><p class="c4 c21"><span class="c23">DFS explores as far as possible along each branch before backtracking, whereas BFS explores all the nodes at the present depth before moving on to the next level.</span></p><p class="c4 c21"><span class="c23">DFS Algorithm:</span></p><ol class="c14 lst-kix_diwc1vs3x2ry-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c23">Pick a starting vertex or node and mark it visited.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Explore one of its neighbors that is not yet visited and mark it visited.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Repeat step 2 for the newly visited node.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">If no unvisited neighbors are available, backtrack to the previous node and repeat step 2 until all nodes are visited.</span></li></ol><p class="c4 c21"><span class="c23">BFS Algorithm:</span></p><ol class="c14 lst-kix_ts7sqvtecfsc-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c23">Pick a starting vertex or node and add it to a queue.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">While the queue is not empty, dequeue a vertex and mark it visited.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Enqueue all the neighbors of the visited vertex that are not already visited.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Repeat steps 2 and 3 until the queue is empty.</span></li></ol><p class="c4 c21"><span class="c12">Here is an example C++ code for DFS and BFS graph traversal:</span></p><p class="c4"><span class="c8">#include &lt;iostream&gt;</span></p><p class="c4"><span class="c8">#include &lt;vector&gt;</span></p><p class="c4"><span class="c8">#include &lt;queue&gt;</span></p><p class="c4"><span class="c8">using namespace std;</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">// A utility function to add an edge to the graph</span></p><p class="c4"><span class="c8">void addEdge(vector&lt;int&gt; adj[], int u, int v) {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; adj[u].push_back(v);</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; adj[v].push_back(u);</span></p><p class="c4"><span class="c8">}</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">// DFS traversal of the vertices reachable from v</span></p><p class="c4"><span class="c8">void DFSUtil(vector&lt;int&gt; adj[], int v, bool visited[]) {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; visited[v] = true;</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; cout &lt;&lt; v &lt;&lt; &quot; &quot;;</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; for (int i = 0; i &lt; adj[v].size(); ++i) {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; if (!visited[adj[v][i]]) {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; DFSUtil(adj, adj[v][i], visited);</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c8">}</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">// DFS traversal of the vertices reachable from a given node</span></p><p class="c4"><span class="c8">void DFS(vector&lt;int&gt; adj[], int v) {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; bool visited[adj-&gt;size()] = {false};</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; DFSUtil(adj, v, visited);</span></p><p class="c4"><span class="c8">}</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">// BFS traversal of the vertices reachable from a given node</span></p><p class="c4"><span class="c8">void BFS(vector&lt;int&gt; adj[], int v) {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; bool visited[adj-&gt;size()] = {false};</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; queue&lt;int&gt; q;</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; visited[v] = true;</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; q.push(v);</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; while (!q.empty()) {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; int curr = q.front();</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; q.pop();</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; curr &lt;&lt; &quot; &quot;;</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; adj[curr].size(); ++i) {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (!visited[adj[curr][i]]) {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; visited[adj[curr][i]] = true;</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; q.push(adj[curr][i]);</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c8">}</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">int main() {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; int V = 6;</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; vector&lt;int&gt; adj[V];</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; addEdge(adj, 0, 1);</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; addEdge(adj, 0, 2);</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; addEdge(adj, 1, 2);</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; addEdge(adj, 2, 3);</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; addEdge(adj, 3, 4);</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; addEdge(adj, 4, 5);</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; cout &lt;&lt; &quot;DFS Traversal (starting from vertex 0): &quot;;</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; DFS(adj, 0);</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; cout &lt;&lt; &quot;\nBFS Traversal (starting from vertex 0): &quot;;</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; BFS(adj, 0);</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; return 0;</span></p><p class="c4"><span class="c8">}</span></p><p class="c3"><span class="c8"></span></p><p class="c3"><span class="c8"></span></p><p class="c4">
                               
                               
</fieldset>
           <fieldset class="topic-card">

                               <span class="topics">Algorithm for stack, queue, and circular queue:</span>
                               
                               
                               
                               
                               <span class="c11">&nbsp;These are data structures used for storing and accessing data in a specific order. A stack is a Last-In-First-Out (LIFO) data structure, while a queue is a First-In-First-Out (FIFO) data structure. A circular queue is a queue where the last element is connected to the first element to form a circular structure.</span></p><p class="c4"><span class="c11">Stack Algorithm:</span></p><ol class="c14 lst-kix_at9uki5ztbt-0 start" start="1"><li class="c4 c6 li-bullet-0"><span class="c11">Create an empty stack.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Push elements onto the stack by adding them to the top of the stack.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Pop elements from the stack by removing them from the top of the stack.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Peek at the top element of the stack without removing it using the top function.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Check if the stack is empty using the empty function.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Get the size of the stack using the size function.</span></li></ol><p class="c4 c6"><span class="c8">#include &lt;stdio.h&gt;</span></p><p class="c4 c6"><span class="c8">#include &lt;stdlib.h&gt;</span></p><p class="c4 c6"><span class="c8">#define MAX_SIZE 10</span></p><p class="c3 c6"><span class="c8"></span></p><p class="c4 c6"><span class="c8">int stack[MAX_SIZE], top = -1;</span></p><p class="c3 c6"><span class="c8"></span></p><p class="c4 c6"><span class="c8">void push(int x) {</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; if (top == MAX_SIZE - 1) {</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Error: Stack overflow\n&quot;);</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; return;</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; stack[++top] = x;</span></p><p class="c4 c6"><span class="c8">}</span></p><p class="c3 c6"><span class="c8"></span></p><p class="c4 c6"><span class="c8">void pop() {</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; if (top == -1) {</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Error: Stack underflow\n&quot;);</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; return;</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; top--;</span></p><p class="c4 c6"><span class="c8">}</span></p><p class="c3 c6"><span class="c8"></span></p><p class="c4 c6"><span class="c8">int peek() {</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; if (top == -1) {</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Error: Stack is empty\n&quot;);</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; return -1;</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; return stack[top];</span></p><p class="c4 c6"><span class="c8">}</span></p><p class="c3 c6"><span class="c8"></span></p><p class="c4 c6"><span class="c8">int main() {</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; push(10);</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; push(20);</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; push(30);</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; printf(&quot;%d\n&quot;, peek());</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; pop();</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; printf(&quot;%d\n&quot;, peek());</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; pop();</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; printf(&quot;%d\n&quot;, peek());</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; pop();</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; printf(&quot;%d\n&quot;, peek());</span></p><p class="c4 c6"><span class="c8">&nbsp; &nbsp; return 0;</span></p><p class="c4 c6"><span class="c8">}</span></p><p class="c3 c6"><span class="c11"></span></p><p class="c3 c6"><span class="c11"></span></p><p class="c4"><span class="c11">Queue Algorithm:</span></p><ol class="c14 lst-kix_vltu8p93c514-0 start" start="1"><li class="c4 c6 li-bullet-0"><span class="c11">Create an empty queue.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Enqueue elements onto the queue by adding them to the rear of the queue.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Dequeue elements from the queue by removing them from the front of the queue.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Peek at the front element of the queue without removing it using the front function.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Peek at the rear element of the queue without removing it using the back function.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Check if the queue is empty using the empty function.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Get the size of the queue using the size function.</span></li></ol><p class="c4 c6"><span class="c11 c15">#include &lt;stdio.h&gt;</span></p><p class="c4 c6"><span class="c11 c15">#include &lt;stdlib.h&gt;</span></p><p class="c4 c6"><span class="c11 c15">#define MAX_SIZE 10</span></p><p class="c3 c6"><span class="c11 c15"></span></p><p class="c4 c6"><span class="c11 c15">int queue[MAX_SIZE], front = 0, rear = -1;</span></p><p class="c3 c6"><span class="c11 c15"></span></p><p class="c4 c6"><span class="c11 c15">void enqueue(int x) {</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; if (rear == MAX_SIZE - 1) {</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Error: Queue overflow\n&quot;);</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; &nbsp; &nbsp; return;</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; }</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; queue[++rear] = x;</span></p><p class="c4 c6"><span class="c11 c15">}</span></p><p class="c3 c6"><span class="c11 c15"></span></p><p class="c4 c6"><span class="c11 c15">void dequeue() {</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; if (front &gt; rear) {</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Error: Queue underflow\n&quot;);</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; &nbsp; &nbsp; return;</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; }</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; front++;</span></p><p class="c4 c6"><span class="c11 c15">}</span></p><p class="c3 c6"><span class="c11 c15"></span></p><p class="c4 c6"><span class="c11 c15">int peek() {</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; if (front &gt; rear) {</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Error: Queue is empty\n&quot;);</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; &nbsp; &nbsp; return -1;</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; }</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; return queue[front];</span></p><p class="c4 c6"><span class="c11 c15">}</span></p><p class="c3 c6"><span class="c11 c15"></span></p><p class="c4 c6"><span class="c11 c15">int main() {</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; enqueue(10);</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; enqueue(20);</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; enqueue(30);</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; printf(&quot;%d\n&quot;, peek());</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; dequeue();</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; printf(&quot;%d\n&quot;, peek());</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; dequeue();</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; printf(&quot;%d\n&quot;, peek());</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; dequeue();</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; printf(&quot;%d\n&quot;, peek());</span></p><p class="c4 c6"><span class="c11 c15">&nbsp; &nbsp; return 0;</span></p><p class="c4 c6"><span class="c11 c15">}</span></p><p class="c3 c6"><span class="c11"></span></p><p class="c3 c6"><span class="c11"></span></p><p class="c4"><span class="c11">Circular Queue Algorithm:</span></p><ol class="c14 lst-kix_fc2o6u79bnlu-0 start" start="1"><li class="c4 c6 li-bullet-0"><span class="c11">Create an empty circular queue with a fixed size.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Initialize the front and rear indices to 0.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Enqueue elements onto the queue by adding them to the rear of the queue and incrementing the rear index.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Dequeue elements from the queue by removing them from the front of the queue and incrementing the front index.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Peek at the front element of the queue without removing it using the front function.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Peek at the rear element of the queue without removing it using the rear function.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Check if the queue is empty using the empty function.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Check if the queue is full using the full function, which checks if the number of elements in the queue is equal to its size. If the queue is full, new elements cannot be enqueued until some elements are dequeued first.</span></li></ol><p class="c4 c6"><span class="c11 c24">#include &lt;stdio.h&gt;</span></p><p class="c4 c6"><span class="c11 c24">#include &lt;stdlib.h&gt;</span></p><p class="c4 c6"><span class="c11 c24">#define MAX_SIZE 10</span></p><p class="c3 c6"><span class="c11 c24"></span></p><p class="c4 c6"><span class="c11 c24">int queue[MAX_SIZE], front = 0, rear = -1, size = 0;</span></p><p class="c3 c6"><span class="c11 c24"></span></p><p class="c4 c6"><span class="c11 c24">void enqueue(int x) {</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; if (size == MAX_SIZE) {</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Error: Queue overflow\n&quot;);</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; &nbsp; &nbsp; return;</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; }</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; rear = (rear + 1) % MAX_SIZE;</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; queue[rear] = x;</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; size++;</span></p><p class="c4 c6"><span class="c11 c24">}</span></p><p class="c3 c6"><span class="c11 c24"></span></p><p class="c4 c6"><span class="c11 c24">void dequeue() {</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; if (size == 0) {</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Error: Queue underflow\n&quot;);</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; &nbsp; &nbsp; return;</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; }</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; front = (front + 1) % MAX_SIZE;</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; size--;</span></p><p class="c4 c6"><span class="c11 c24">}</span></p><p class="c3 c6"><span class="c11 c24"></span></p><p class="c4 c6"><span class="c11 c24">int peek() {</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; if (size == 0) {</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Error: Queue is empty\n&quot;);</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; &nbsp; &nbsp; return -1;</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; }</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; return queue[front];</span></p><p class="c4 c6"><span class="c11 c24">}</span></p><p class="c3 c6"><span class="c11 c24"></span></p><p class="c4 c6"><span class="c11 c24">int main() {</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; enqueue(10);</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; enqueue(20);</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; enqueue(30);</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; printf(&quot;%d\n&quot;, peek());</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; dequeue();</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; printf(&quot;%d\n&quot;, peek());</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; dequeue();</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; printf(&quot;%d\n&quot;, peek());</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; dequeue();</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; printf(&quot;%d\n&quot;, peek());</span></p><p class="c4 c6"><span class="c11 c24">&nbsp; &nbsp; return 0;</span></p><p class="c4 c6"><span class="c11 c24">}</span></p><p class="c3 c6"><span class="c11"></span></p><p class="c3 c6"><span class="c11"></span></p><p class="c3"><span class="c11"></span></p><p class="c4">
                                   
                                   </fieldset>
           <fieldset class="topic-card">
                                   
                                   <span class="topics">Types of hashing and types of collision:</span>
                                   

                                   
                                   <span class="c11">&nbsp;Hashing is a technique used for efficient storage and retrieval of data in a hash table. There are different types of hashing functions, including division method, multiplication method, and universal hashing. Collisions occur when two or more keys are mapped to the same hash value, and there are different strategies for handling collisions, including chaining and open addressing.</span></p><p class="c4 c21"><span class="c23">Hashing is a technique used to map data of arbitrary size to a fixed size. It is often used in data structures and algorithms to quickly look up data by its key. There are various types of hashing and collision resolution methods.</span></p><p class="c4 c21"><span class="c23">Types of Hashing:</span></p><ol class="c14 lst-kix_z7ai3k2b1ppr-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c23">Division method: In this method, the key is divided by a prime number and the remainder is used as the index.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Multiplication method: In this method, the key is multiplied by a constant value between 0 and 1, and the fractional part of the result is multiplied by the size of the hash table.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Universal hashing: In this method, the hash function is chosen randomly from a set of hash functions.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Perfect hashing: In this method, a hash function is chosen to minimize collisions for a specific set of keys.</span></li></ol><p class="c4 c21"><span class="c23">Types of Collision:</span></p><p class="c4"><span class="c23">Open addressing: In this method, when a collision occurs, a new slot is found in the hash table until an empty slot is found.</span></p><p class="c4"><span class="c23">a. Linear probing: In this method, the next slot in the hash table is checked until an empty slot is found.</span></p><p class="c4"><span class="c23">b. Quadratic probing: In this method, the next slot in the hash table is checked using a quadratic function until an empty slot is found.</span></p><ol class="c14 lst-kix_obbh4oor7e7i-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c23">c. Double hashing: In this method, a second hash function is used to find the next slot in the hash table.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Separate chaining: In this method, each slot in the hash table contains a linked list of elements that hash to that slot. When a collision occurs, the new element is added to the end of the linked list.</span></li></ol><p class="c4"><span class="c19">Here&#39;s an example of a simple hashing program in C using linear probing collision </span><span class="c0">resolution:</span></p><p class="c4"><span class="c0">#include &lt;stdio.h&gt;</span></p><p class="c3"><span class="c0"></span></p><p class="c4"><span class="c0">#define SIZE 10</span></p><p class="c3"><span class="c0"></span></p><p class="c4"><span class="c0">int hash(int key) {</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; return key % SIZE;</span></p><p class="c4"><span class="c0">}</span></p><p class="c3"><span class="c0"></span></p><p class="c4"><span class="c0">void insert(int key, int ht[]) {</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; int index = hash(key);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; int i = 0;</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; while (ht[(index + i) % SIZE] != -1) {</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; i++;</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; ht[(index + i) % SIZE] = key;</span></p><p class="c4"><span class="c0">}</span></p><p class="c3"><span class="c0"></span></p><p class="c4"><span class="c0">void display(int ht[]) {</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; printf(&quot;Hash table:\n&quot;);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; for (int i = 0; i &lt; SIZE; i++) {</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;%d &quot;, ht[i]);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; printf(&quot;\n&quot;);</span></p><p class="c4"><span class="c0">}</span></p><p class="c3"><span class="c0"></span></p><p class="c4"><span class="c0">int search(int key, int ht[]) {</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; int index = hash(key);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; int i = 0;</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; while (ht[(index + i) % SIZE] != key) {</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; if (ht[(index + i) % SIZE] == -1) {</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return -1;</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; i++;</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; return (index + i) % SIZE;</span></p><p class="c4"><span class="c0">}</span></p><p class="c3"><span class="c0"></span></p><p class="c4"><span class="c0">int delete(int key, int ht[]) {</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; int index = search(key, ht);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; if (index == -1) {</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; return -1;</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; ht[index] = -1;</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; return index;</span></p><p class="c4"><span class="c0">}</span></p><p class="c3"><span class="c0"></span></p><p class="c4"><span class="c0">int main() {</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; int ht[SIZE];</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; for (int i = 0; i &lt; SIZE; i++) {</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; &nbsp; &nbsp; ht[i] = -1;</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; insert(10, ht);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; insert(20, ht);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; insert(30, ht);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; insert(40, ht);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; insert(50, ht);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; display(ht);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; int index = search(40, ht);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; printf(&quot;Key 40 found at index %d\n&quot;, index);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; index = delete(30, ht);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; printf(&quot;Key 30 deleted from index %d\n&quot;, index);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; display(ht);</span></p><p class="c4"><span class="c0">&nbsp; &nbsp; return 0;</span></p><p class="c4"><span class="c0">}</span></p><p class="c3"><span class="c23 c21"></span></p><p class="c4"><span class="c19">This program creates a hash table of size 10 using an array </span><span class="c37 c21">ht</span><span class="c19">. It uses the </span><span class="c37 c21">hash</span><span class="c19">&nbsp;function to map keys to their corresponding index in the array. Keys are inserted into the hash table using the </span><span class="c37 c21">insert</span><span class="c19">&nbsp;function, which resolves collisions using linear probing. The </span><span class="c37 c21">search</span><span class="c19">&nbsp;function returns the index of a key in the hash table, and the </span><span class="c37 c21">delete</span><span class="c19">&nbsp;function removes a key from the hash table. The </span><span class="c37 c21">display</span><span class="c23 c21">&nbsp;function prints the contents of the hash table.</span></p><p class="c4">
                                       
                                   </fieldset>
           <fieldset class="topic-card">    

                                       <span class="topics">Tower of Hanoi:</span>
                                       

                                       
                                       <span class="c11">&nbsp;This is a mathematical puzzle that involves moving a stack of disks from one peg to another, following specific rules. This puzzle can be solved recursively using an algorithm that divides the problem into smaller subproblems.</span></p><p class="c4 c21"><span class="c23">The Tower of Hanoi is a classic puzzle game consisting of three rods and a series of disks of different sizes that can slide onto any rod. The puzzle starts with the disks in a neat stack in ascending order of size on one rod, the smallest at the top, thus making a conical shape.</span></p><p class="c4 c21"><span class="c23">The objective of the puzzle is to move the entire stack to another rod, obeying the following simple rules:</span></p><ol class="c14 lst-kix_tbxi5c8ch0kt-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c23">Only one disk can be moved at a time.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Each move consists of taking the upper disk from one of the stacks and placing it on top of another stack or on an empty rod.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">No disk may be placed on top of a smaller disk.</span></li></ol><p class="c4 c21"><span class="c23">Here&#39;s a recursive C++ program for solving the Tower of Hanoi problem:</span></p><p class="c4"><span class="c10">#include &lt;iostream&gt;</span></p><p class="c4"><span class="c10">using namespace std;</span></p><p class="c3"><span class="c10"></span></p><p class="c4"><span class="c10">// Function to solve the Tower of Hanoi puzzle</span></p><p class="c4"><span class="c10">void towerOfHanoi(int n, char fromRod, char toRod, char auxRod) {</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; if (n == 1) {</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; &quot;Move disk 1 from rod &quot; &lt;&lt; fromRod &lt;&lt; &quot; to rod &quot; &lt;&lt; toRod &lt;&lt; endl;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; &nbsp; return;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; towerOfHanoi(n - 1, fromRod, auxRod, toRod);</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; cout &lt;&lt; &quot;Move disk &quot; &lt;&lt; n &lt;&lt; &quot; from rod &quot; &lt;&lt; fromRod &lt;&lt; &quot; to rod &quot; &lt;&lt; toRod &lt;&lt; endl;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; towerOfHanoi(n - 1, auxRod, toRod, fromRod);</span></p><p class="c4"><span class="c10">}</span></p><p class="c3"><span class="c10"></span></p><p class="c4"><span class="c10">int main() {</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; int n;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; cout &lt;&lt; &quot;Enter the number of disks: &quot;;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; cin &gt;&gt; n;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; towerOfHanoi(n, &#39;A&#39;, &#39;C&#39;, &#39;B&#39;);</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; return 0;</span></p><p class="c4"><span class="c10">}</span></p><p class="c3"><span class="c11"></span></p><p class="c4"><span class="c19">In this program, </span><span class="c37 c21">n</span><span class="c19">&nbsp;represents the number of disks, </span><span class="c37 c21">fromRod</span><span class="c19">&nbsp;represents the rod from which the disk is to be moved, </span><span class="c37 c21">toRod</span><span class="c19">&nbsp;represents the rod on which the disk is to be moved, and </span><span class="c37 c21">auxRod</span><span class="c19">&nbsp;represents the auxiliary rod to be used. The </span><span class="c37 c21">towerOfHanoi</span><span class="c19">&nbsp;function is a recursive function that moves the disks from the </span><span class="c37 c21">fromRod</span><span class="c19">&nbsp;to the </span><span class="c37 c21">toRod</span><span class="c19">&nbsp;using the </span><span class="c37 c21">auxRod</span><span class="c19">. The base case is when there is only one disk, in which case it is directly moved from the </span><span class="c37 c21">fromRod</span><span class="c19">&nbsp;to the </span><span class="c37 c21">toRod</span><span class="c19">. For </span><span class="c37 c21">n &gt; 1</span><span class="c19">, the function recursively moves </span><span class="c37 c21">n-1</span><span class="c19">&nbsp;disks from the </span><span class="c37 c21">fromRod</span><span class="c19">&nbsp;to the </span><span class="c37 c21">auxRod</span><span class="c19">, moves the </span><span class="c37 c21">nth</span><span class="c19">&nbsp;disk from the </span><span class="c37 c21">fromRod</span><span class="c19">&nbsp;to the </span><span class="c37 c21">toRod</span><span class="c19">, and finally recursively moves the </span><span class="c37 c21">n-1</span><span class="c19">&nbsp;disks from the </span><span class="c37 c21">auxRod</span><span class="c19">&nbsp;to the </span><span class="c37 c21">toRod</span><span class="c19">.</span></p><p class="c4">
                                           
                                   </fieldset>
           <fieldset class="topic-card">        

                                           <span class="topics">Linear search and binary search:</span>
                                           
                                           
                                           
                                           <span class="c11">&nbsp;These are two algorithms used for searching for a specific element in a data set. Linear search checks each element in the data set sequentially until the desired element is found, while binary search divides the data set in half at each step until the desired element is found.</span></p><p class="c4 c21"><span class="c23">Linear search and binary search are two commonly used search algorithms in computer science. The linear search algorithm is also known as sequential search, and it is used to find a particular element in a list by traversing the list from the beginning to the end, one element at a time. On the other hand, the binary search algorithm is used to find a particular element in a sorted list by repeatedly dividing the search interval in half.</span></p><p class="c4 c21"><span class="c23">Here are the algorithms for linear search and binary search:</span></p><p class="c4 c21"><span class="c23">Linear search algorithm:</span></p><ol class="c14 lst-kix_sir65zcnjnfn-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c23">Start at the first element of the list.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Compare the target element with the current element of the list.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">If the target element matches the current element, return the index of the current element.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">If the target element does not match the current element, move to the next element in the list.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">If the end of the list is reached without finding the target element, return -1 to indicate that the element was not found.</span></li></ol><p class="c4 c21"><span class="c23">Here is a C++ program to perform a linear search on an integer array:</span></p><p class="c4"><span class="c11 c29">#include &lt;iostream&gt;</span></p><p class="c4"><span class="c11 c29">using namespace std;</span></p><p class="c3"><span class="c11 c29"></span></p><p class="c4"><span class="c11 c29">int linearSearch(int arr[], int n, int x) {</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp;for (int i = 0; i &lt; n; i++) {</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp; &nbsp; if (arr[i] == x) {</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return i;</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp;}</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp;return -1;</span></p><p class="c4"><span class="c11 c29">}</span></p><p class="c3"><span class="c11 c29"></span></p><p class="c4"><span class="c11 c29">int main() {</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp;int arr[] = {2, 5, 7, 9, 12, 15};</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp;int n = sizeof(arr) / sizeof(arr[0]);</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp;int x = 9;</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp;int index = linearSearch(arr, n, x);</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp;if (index != -1) {</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp; &nbsp; cout &lt;&lt; &quot;Element found at index &quot; &lt;&lt; index &lt;&lt; endl;</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp;} else {</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp; &nbsp; cout &lt;&lt; &quot;Element not found&quot; &lt;&lt; endl;</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp;}</span></p><p class="c4"><span class="c11 c29">&nbsp; &nbsp;return 0;</span></p><p class="c4"><span class="c11 c29">}</span></p><p class="c3"><span class="c11"></span></p><p class="c4 c21"><span class="c23">Binary search algorithm:</span></p><ol class="c14 lst-kix_lu9utmgdf9kv-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c23">Set the lower bound to the first element of the list and the upper bound to the last element of the list.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Calculate the middle element of the search interval.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">Compare the middle element with the target element.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">If the middle element matches the target element, return the index of the middle element.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">If the middle element is greater than the target element, set the upper bound to the middle element minus one and repeat from step 2.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">If the middle element is less than the target element, set the lower bound to the middle element plus one and repeat from step 2.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c23">If the lower bound becomes greater than the upper bound, the element was not found, return -1.</span></li></ol><p class="c4 c21"><span class="c23">Here is a C++ program to perform a binary search on an integer array:</span></p><p class="c4"><span class="c10">#include &lt;iostream&gt;</span></p><p class="c4"><span class="c10">using namespace std;</span></p><p class="c3"><span class="c10"></span></p><p class="c4"><span class="c10">int binarySearch(int arr[], int n, int x) {</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;int left = 0, right = n - 1;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;while (left &lt;= right) {</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; int mid = left + (right - left) / 2;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; if (arr[mid] == x) {</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return mid;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; if (arr[mid] &lt; x) {</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;left = mid + 1;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; } else {</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;right = mid - 1;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;}</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;return -1;</span></p><p class="c4"><span class="c10">}</span></p><p class="c3"><span class="c10"></span></p><p class="c4"><span class="c10">int main() {</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;int arr[] = {2, 5, 7, 9, 12, 15};</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;int n = sizeof(arr) / sizeof(arr[0]);</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;int x = 9;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;int index = binarySearch(arr, n, x);</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;if (index != -1) {</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; cout &lt;&lt; &quot;Element found at index &quot; &lt;&lt; index &lt;&lt; endl;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;} else {</span></p><p class="c4"><span class="c10">&nbsp; &nbsp; &nbsp; cout &lt;&lt; &quot;Element not found&quot; &lt;&lt; endl;</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;}</span></p><p class="c4"><span class="c10">&nbsp; &nbsp;return </span></p><p class="c3"><span class="c11"></span></p><p class="c3"><span class="c11"></span></p><p class="c4">
                                               
                                               
</fieldset>
           <fieldset class="topic-card">

                                               <span class="topics">Recursive binary search:</span>


                                               
                                               
                                               <span class="c11">&nbsp;This is a variation of binary search that uses recursion to implement the algorithm.</span></p><p class="c4"><span class="c11">Algorithm for Recursive binary search:</span></p><p class="c4"><span class="c11">The recursive binary search algorithm can be defined as follows:</span></p><ol class="c14 lst-kix_x91omd3713c9-0 start" start="1"><li class="c4 c6 li-bullet-0"><span class="c11">Start by defining the search range as the entire array.</span></li><li class="c4 c6 li-bullet-0"><span class="c52">Calculate the middle index of the search range using the formula: </span><span class="c56">mid = (low + high) / 2</span><span class="c11">.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">Compare the element at the middle index with the target element.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">If the middle element is equal to the target element, return the middle index.</span></li><li class="c4 c6 li-bullet-0"><span class="c11">If the middle element is greater than the target element, repeat the search on the left half of the search range (i.e., set the new high to mid - 1).</span></li><li class="c4 c6 li-bullet-0"><span class="c11">If the middle element is less than the target element, repeat the search on the right half of the search range (i.e., set the new low to mid + 1).</span></li><li class="c4 c6 li-bullet-0"><span class="c11">If the search range becomes empty (i.e., low &gt; high), the target element is not present in the array, return -1.</span></li></ol><p class="c4"><span class="c11">Here is a pseudocode implementation of the recursive binary search algorithm:</span></p><p class="c4"><span class="c8">#include &lt;iostream&gt;</span></p><p class="c4"><span class="c8">using namespace std;</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">// Recursive binary search function</span></p><p class="c4"><span class="c8">int binarySearchRecursive(int arr[], int left, int right, int x) {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; if (right &gt;= left) {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; int mid = left + (right - left) / 2;</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; // If the element is present at the middle</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; if (arr[mid] == x)</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return mid;</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; // If element is smaller than mid, then it can only be present in left subarray</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; if (arr[mid] &gt; x)</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; return binarySearchRecursive(arr, left, mid - 1, x);</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; // Else the element can only be present in right subarray</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; return binarySearchRecursive(arr, mid + 1, right, x);</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; }</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">&nbsp; &nbsp; // If element is not present in array</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; return -1;</span></p><p class="c4"><span class="c8">}</span></p><p class="c3"><span class="c8"></span></p><p class="c4"><span class="c8">int main() {</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; int arr[] = {2, 3, 4, 10, 40};</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; int n = sizeof(arr) / sizeof(arr[0]);</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; int x = 10;</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; int result = binarySearchRecursive(arr, 0, n - 1, x);</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; (result == -1) ? cout &lt;&lt; &quot;Element is not present in array&quot;</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;: cout &lt;&lt; &quot;Element is present at index &quot; &lt;&lt; result;</span></p><p class="c4"><span class="c8">&nbsp; &nbsp; return 0;</span></p><p class="c4"><span class="c8">}</span></p><p class="c3"><span class="c11"></span></p><p class="c4 c21"><span class="c35">This code implements the recursive binary search algorithm to search for an element </span><span class="c22">x</span><span class="c35">&nbsp;in a sorted array </span><span class="c22">arr</span><span class="c35">. The function </span><span class="c22">binarySearchRecursive</span><span class="c23">&nbsp;takes four arguments: the array, the leftmost index, the rightmost index, and the element to be searched.</span></p><p class="c4 c21"><span class="c23">The function first checks if the right index is greater than or equal to the left index. If not, the element is not present in the array and the function returns -1. If the right index is greater than or equal to the left index, it calculates the middle index and checks if the element is present at the middle. If the element is present at the middle, it returns the middle index. If the element is smaller than the middle element, it recursively calls the function for the left subarray. If the element is larger than the middle element, it recursively calls the function for the right subarray.</span></p><p class="c3"><span class="c11"></span></p><p class="c4">
                                                   
                                                   
</fieldset>
           <fieldset class="topic-card">
                                                   <span class="topics">Sorting algorithms (bubble, selection, insertion, merge, quick, radix): </span>
                                                   
                                                   
                                                   
                                                   <span class="c11">These are different algorithms used for sorting data in a specific order. Bubble sort repeatedly compares adjacent elements and swaps them if they are in the wrong order, while selection sort selects the smallest element in the unsorted portion of the data and swaps it with the first element of the sorted portion. Insertion sort inserts each element in the correct position in a sorted list. Merge sort and quicksort are both divide-and-conquer algorithms that recursively divide the data set into smaller subproblems, sort those subproblems, and then merge them back together. Radix sort sorts the data by digit position, starting from the least significant digit.</span></p><p class="c4 c21"><span class="c23">Sure, here are the algorithms and sample C++ programs for various sorting algorithms:</span></p><ol class="c14 lst-kix_tib783e0521k-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c20">Bubble Sort:</span></li></ol><p class="c4 c21"><span class="c20">Algorithm:</span></p><ol class="c14 lst-kix_rm70wd3xg1ab-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c20">Compare each pair of adjacent elements from the beginning of an array and, if they are in reversed order, swap them.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c20">If at least one swap has been made, repeat step 1.</span></li></ol><p class="c4 c21"><span class="c20">C++ Code:</span></p><p class="c4"><span class="c2">void bubbleSort(int arr[], int n) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; bool swapped;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; for (int i = 0; i &lt; n - 1; i++) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; swapped = false;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; for (int j = 0; j &lt; n - i - 1; j++) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (arr[j] &gt; arr[j + 1]) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(arr[j], arr[j + 1]);</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swapped = true;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; if (swapped == false)</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; break;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">}</span></p><p class="c3"><span class="c2"></span></p><ol class="c14 lst-kix_rbbsbvnmo888-0 start" start="2"><li class="c4 c6 c21 li-bullet-0"><span class="c20">Selection Sort:</span></li></ol><p class="c4 c21"><span class="c20">Algorithm:</span></p><ol class="c14 lst-kix_ylybvxdns7m6-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c20">Find the minimum element in the array and swap it with the first unsorted element.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c20">Repeat step 1 for the remaining unsorted elements.</span></li></ol><p class="c4 c21"><span class="c20">C++ Code:</span></p><p class="c4"><span class="c2">void selectionSort(int arr[], int n) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; int i, j, minIndex;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; for (i = 0; i &lt; n - 1; i++) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; minIndex = i;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; for (j = i + 1; j &lt; n; j++) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; if (arr[j] &lt; arr[minIndex])</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; minIndex = j;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; swap(arr[i], arr[minIndex]);</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">}</span></p><p class="c3"><span class="c2"></span></p><ol class="c14 lst-kix_8xtigtshuhsl-0 start" start="3"><li class="c4 c6 c21 li-bullet-0"><span class="c20">Insertion Sort:</span></li></ol><p class="c4 c21"><span class="c20">Algorithm:</span></p><ol class="c14 lst-kix_f6je1mwgeu8z-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c20">Iterate from arr[1] to arr[n] over the array.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c20">Compare the current element (key) to its predecessor.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c20">If the key element is smaller than its predecessor, compare it to the elements before. Move the greater elements one position up to make space for the swapped element.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c20">Repeat step 3 until the correct position for the key element is found.</span></li></ol><p class="c4 c21"><span class="c20">C++ Code:</span></p><p class="c4"><span class="c2">void insertionSort(int arr[], int n) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; int i, key, j;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; for (i = 1; i &lt; n; i++) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; key = arr[i];</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; j = i - 1;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; while (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arr[j + 1] = arr[j];</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j = j - 1;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; arr[j + 1] = key;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">}</span></p><p class="c3"><span class="c2"></span></p><ol class="c14 lst-kix_sb50dhyaie1y-0 start" start="4"><li class="c4 c6 c21 li-bullet-0"><span class="c20">Merge Sort:</span></li></ol><p class="c4 c21"><span class="c20">Algorithm:</span></p><ol class="c14 lst-kix_pu69hm6jx4-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c20">Divide the unsorted list into n sublists, each containing one element (a list of one element is considered sorted).</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c20">Repeatedly merge sublists to produce new sorted sublists until there is only one sublist remaining.</span></li></ol><p class="c4"><span class="c2">#include &lt;iostream&gt;</span></p><p class="c4"><span class="c2">#include &lt;vector&gt;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">using namespace std;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">// Function to merge two sorted sub-arrays into a single sorted array</span></p><p class="c4"><span class="c2">void merge(vector&lt;int&gt;&amp; arr, int low, int mid, int high) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; vector&lt;int&gt; temp(high - low + 1);</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; int i = low, j = mid + 1, k = 0;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp; &nbsp; while (i &lt;= mid &amp;&amp; j &lt;= high) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; if (arr[i] &lt;= arr[j]) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp[k++] = arr[i++];</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; } else {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp[k++] = arr[j++];</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp; &nbsp; while (i &lt;= mid) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; temp[k++] = arr[i++];</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp; &nbsp; while (j &lt;= high) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; temp[k++] = arr[j++];</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp; &nbsp; for (i = low, k = 0; i &lt;= high; i++, k++) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; arr[i] = temp[k];</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">// Function to perform merge sort on the given array</span></p><p class="c4"><span class="c2">void mergeSort(vector&lt;int&gt;&amp; arr, int low, int high) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; if (low &lt; high) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; int mid = (low + high) / 2;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; mergeSort(arr, low, mid);</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; mergeSort(arr, mid + 1, high);</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; merge(arr, low, mid, high);</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">// Driver function</span></p><p class="c4"><span class="c2">int main() {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; vector&lt;int&gt; arr = {9, 4, 8, 3, 1, 6, 5, 2, 7};</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; int n = arr.size();</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp; &nbsp; mergeSort(arr, 0, n - 1);</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp; &nbsp; cout &lt;&lt; &quot;Sorted array:&quot;;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; for (int x : arr) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; &quot; &quot; &lt;&lt; x;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; cout &lt;&lt; endl;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp; &nbsp; return 0;</span></p><p class="c4"><span class="c2">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4 c21"><span class="c20">Quick sort is a divide-and-conquer algorithm that sorts an array by partitioning it into two subarrays, recursively sorting the subarrays, and then combining the sorted subarrays. Here is the algorithm:</span></p><ol class="c14 lst-kix_alw2wz55bd4d-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c20">Choose a pivot element from the array. This can be any element in the array, but it is usually the first or last element.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c20">Partition the array into two subarrays: one subarray containing all the elements smaller than the pivot, and one subarray containing all the elements greater than or equal to the pivot. The pivot element itself is in its final sorted position.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c20">Recursively apply the quicksort algorithm to the subarrays until they have length 0 or 1.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c20">Combine the sorted subarrays by concatenating the smaller subarray, the pivot element, and the larger subarray.</span></li></ol><p class="c4 c21"><span class="c20">Here is an implementation of the quicksort algorithm in C++:</span></p><p class="c4"><span class="c2">#include &lt;iostream&gt;</span></p><p class="c4"><span class="c2">#include &lt;vector&gt;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">using namespace std;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">// Function to partition the array around the pivot element</span></p><p class="c4"><span class="c2">int partition(vector&lt;int&gt;&amp; arr, int low, int high) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; int pivot = arr[low]; // choose the first element as the pivot</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; int i = low + 1; // start from the second element</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; int j = high;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; while (i &lt;= j) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; if (arr[i] &lt;= pivot) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; i++;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; } else if (arr[j] &gt; pivot) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; j--;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; } else {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; swap(arr[i], arr[j]);</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; swap(arr[low], arr[j]); // swap the pivot element with the partition index</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; return j; // return the partition index</span></p><p class="c4"><span class="c2">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">// Function to implement the quicksort algorithm</span></p><p class="c4"><span class="c2">void quicksort(vector&lt;int&gt;&amp; arr, int low, int high) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; if (low &lt; high) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; int pivotIndex = partition(arr, low, high);</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; quicksort(arr, low, pivotIndex - 1); // apply quicksort to the left subarray</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; quicksort(arr, pivotIndex + 1, high); // apply quicksort to the right subarray</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">int main() {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; vector&lt;int&gt; arr = {5, 2, 9, 1, 5, 6};</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; quicksort(arr, 0, arr.size() - 1);</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; for (int i = 0; i &lt; arr.size(); i++) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; cout &lt;&lt; endl;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; return 0;</span></p><p class="c4"><span class="c2">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">Quick sort is a divide-and-conquer algorithm that sorts an array by partitioning it into two subarrays, recursively sorting the subarrays, and then combining the sorted subarrays. Here is the algorithm:</span></p><ol class="c14 lst-kix_8f2b8p1d288b-0 start" start="1"><li class="c4 c6 li-bullet-0"><span class="c2">Choose a pivot element from the array. This can be any element in the array, but it is usually the first or last element.</span></li><li class="c4 c6 li-bullet-0"><span class="c2">Partition the array into two subarrays: one subarray containing all the elements smaller than the pivot, and one subarray containing all the elements greater than or equal to the pivot. The pivot element itself is in its final sorted position.</span></li><li class="c4 c6 li-bullet-0"><span class="c2">Recursively apply the quicksort algorithm to the subarrays until they have length 0 or 1.</span></li><li class="c4 c6 li-bullet-0"><span class="c2">Combine the sorted subarrays by concatenating the smaller subarray, the pivot element, and the larger subarray.</span></li></ol><p class="c4"><span class="c2">Here is an implementation of the quicksort algorithm in C++:</span></p><p class="c27 c17"><span class="c39">arduino</span></p><p class="c27 c17"><span class="c25 c49">Copy code</span></p><p class="c27 c17"><span class="c18">#</span><span class="c9">include</span><span class="c18">&nbsp;</span><span class="c46">&lt;iostream&gt;</span><span class="c18">&nbsp;#</span><span class="c9">include</span><span class="c18">&nbsp;</span><span class="c46">&lt;vector&gt;</span><span class="c18">&nbsp;</span><span class="c9">using</span><span class="c18">&nbsp;</span><span class="c9">namespace</span><span class="c18">&nbsp;std; // Function to partition the array around the pivot element </span><span class="c36">int</span><span class="c18">&nbsp;</span><span class="c48">partition</span><span class="c18">(vector&lt;</span><span class="c36">int</span><span class="c18">&gt;&amp; arr, </span><span class="c36">int</span><span class="c18">&nbsp;low, </span><span class="c36">int</span><span class="c18">&nbsp;high) { </span><span class="c36">int</span><span class="c18">&nbsp;pivot = arr[low]; // choose the first element as the pivot </span><span class="c36">int</span><span class="c18">&nbsp;i = low + </span><span class="c36">1</span><span class="c18">; // start from the second element </span><span class="c36">int</span><span class="c18">&nbsp;j = high; </span><span class="c9">while</span><span class="c18">&nbsp;(i &lt;= j) { </span><span class="c9">if</span><span class="c18">&nbsp;(arr[i] &lt;= pivot) { i++; } </span><span class="c9">else</span><span class="c18">&nbsp;</span><span class="c9">if</span><span class="c18">&nbsp;(arr[j] &gt; pivot) { j--; } </span><span class="c9">else</span><span class="c18">&nbsp;{ </span><span class="c33">swap</span><span class="c18">(arr[i], arr[j]); } } </span><span class="c33">swap</span><span class="c18">(arr[low], arr[j]); // swap the pivot element with the partition index </span><span class="c9">return</span><span class="c18">&nbsp;j; // return the partition index } // Function to implement the quicksort algorithm </span><span class="c36">void</span><span class="c18">&nbsp;</span><span class="c48">quicksort</span><span class="c18">(vector&lt;</span><span class="c36">int</span><span class="c18">&gt;&amp; arr, </span><span class="c36">int</span><span class="c18">&nbsp;low, </span><span class="c36">int</span><span class="c18">&nbsp;high) { </span><span class="c9">if</span><span class="c18">&nbsp;(low &lt; high) { </span><span class="c36">int</span><span class="c18">&nbsp;pivotIndex = </span><span class="c33">partition</span><span class="c18">(arr, low, high); </span><span class="c33">quicksort</span><span class="c18">(arr, low, pivotIndex - </span><span class="c36">1</span><span class="c18">); // apply quicksort to the left subarray </span><span class="c33">quicksort</span><span class="c18">(arr, pivotIndex + </span><span class="c36">1</span><span class="c18">, high); // apply quicksort to the right subarray } } </span><span class="c36">int</span><span class="c18">&nbsp;</span><span class="c48">main</span><span class="c18">() { vector&lt;</span><span class="c36">int</span><span class="c18">&gt; arr = {</span><span class="c36">5</span><span class="c18">, </span><span class="c36">2</span><span class="c18">, </span><span class="c36">9</span><span class="c18">, </span><span class="c36">1</span><span class="c18">, </span><span class="c36">5</span><span class="c18">, </span><span class="c36">6</span><span class="c18">}; </span><span class="c33">quicksort</span><span class="c18">(arr, </span><span class="c36">0</span><span class="c18">, arr.</span><span class="c33">size</span><span class="c18">() - </span><span class="c36">1</span><span class="c18">); </span><span class="c9">for</span><span class="c18">&nbsp;(</span><span class="c36">int</span><span class="c18">&nbsp;i = </span><span class="c36">0</span><span class="c18">; i &lt; arr.</span><span class="c33">size</span><span class="c18">(); i++) { cout &lt;&lt; arr[i] &lt;&lt; </span><span class="c46">&quot; &quot;</span><span class="c18">; } cout &lt;&lt; endl; </span><span class="c9">return</span><span class="c18">&nbsp;</span><span class="c36">0</span><span class="c18 c45">; }</span></p><p class="c4"><span class="c2">This implementation uses a partition function to choose a pivot element and partition the array around it, and then recursively applies the quicksort algorithm to the subarrays. The partition function uses two pointers, one starting at the first element and the other starting at the last element, to swap elements until all elements smaller than the pivot are on one side of the partition index and all elements greater than or equal to the pivot are on the other side. The partition index is then swapped with the pivot element, which is now in its final sorted position.</span></p><p class="c4 c21"><span class="c20">Radix sort is a non-comparative sorting algorithm that sorts data by grouping elements with the same values. It is often used to sort elements that have a non-uniform distribution of digits, such as strings or numbers with multiple digits. Here&#39;s the algorithm for radix sort:</span></p><ol class="c14 lst-kix_287trhlfyn66-0 start" start="1"><li class="c4 c6 c21 li-bullet-0"><span class="c20">Find the maximum number in the list and count the number of digits in it.</span></li></ol><p class="c4"><span class="c20">For each digit position (starting from the rightmost digit), do the following:</span></p><p class="c4"><span class="c20">a. Create 10 buckets (0-9).</span></p><p class="c4"><span class="c20">b. Scan through the list of numbers, and for each number:</span></p><p class="c4"><span class="c20">i. Extract the digit at the current position.</span></p><p class="c4"><span class="c20">ii. Insert the number into the corresponding bucket based on the extracted digit.</span></p><ol class="c14 lst-kix_287trhlfyn66-0" start="2"><li class="c4 c6 c21 li-bullet-0"><span class="c20">c. Collect the numbers from the buckets in order and overwrite the original list with the new order.</span></li><li class="c4 c6 c21 li-bullet-0"><span class="c20">The list is now sorted.</span></li></ol><p class="c4 c21"><span class="c20">And here&#39;s a sample C++ code for radix sort:</span></p><p class="c4"><span class="c2">#include &lt;iostream&gt;</span></p><p class="c4"><span class="c2">#include &lt;vector&gt;</span></p><p class="c4"><span class="c2">#include &lt;algorithm&gt;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">using namespace std;</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">void radixSort(vector&lt;int&gt;&amp; arr) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; int maxNum = *max_element(arr.begin(), arr.end());</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; int digits = 0;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; while (maxNum &gt; 0) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; digits++;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; maxNum /= 10;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp; &nbsp; vector&lt;vector&lt;int&gt;&gt; buckets(10);</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp; &nbsp; for (int d = 0; d &lt; digits; d++) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; arr.size(); i++) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; int digit = (arr[i] / static_cast&lt;int&gt;(pow(10, d))) % 10;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buckets[digit].push_back(arr[i]);</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; arr.clear();</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; for (int i = 0; i &lt; 10; i++) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; for (int j = 0; j &lt; buckets[i].size(); j++) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; arr.push_back(buckets[i][j]);</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; buckets[i].clear();</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">}</span></p><p class="c3"><span class="c2"></span></p><p class="c4"><span class="c2">int main() {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; vector&lt;int&gt; arr = {9, 5, 1, 7, 3, 4, 2, 8, 6};</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; radixSort(arr);</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; for (int i = 0; i &lt; arr.size(); i++) {</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; &nbsp; &nbsp; cout &lt;&lt; arr[i] &lt;&lt; &quot; &quot;;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; }</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; cout &lt;&lt; endl;</span></p><p class="c4"><span class="c2">&nbsp; &nbsp; return 0;</span></p><p class="c4"><span class="c2">}</span></p><p class="c3"><span class="c2"></span></p><p class="c3"><span class="c11"></span></p><p class="c3"><span class="c11"></span></p><p class="c4">
                                                       
</fieldset>
           <fieldset class="topic-card">
                                                       
                                                       <span class="topics">Representation of sparse graphs, trees, and graphs:</span>
                                                       
                                                       
                                                       
                                                       <span class="c11">&nbsp;Sparse graphs are graphs that have relatively few edges compared to the number of vertices, while dense graphs have many edges. Sparse graphs can be represented using adjacency lists or sparse matrices, while dense graphs can be represented using adjacency matrices. Trees are a special type of graph where each node has at most one parent, while graphs can have multiple edges and cycles. Trees can be represented using linked lists or arrays, while graphs can be represented using adjacency lists, adjacency matrices, or edge lists.</span></p><p class="c4"><span class="c11">Sparse graphs, trees, and graphs can be represented using different data structures.</span></p><p class="c13"><span class="c11">Sparse graphs:</span></p><ol class="c14 lst-kix_d77uocuovkri-0 start" start="1"><li class="c27 c13 c6 li-bullet-0"><span class="c11">Sparse graphs are those graphs that have relatively fewer edges compared to the maximum number of edges in a graph. Sparse graphs can be represented using an adjacency list or an edge list. In the adjacency list representation, each vertex is represented as a node in a linked list, and the linked list contains all the vertices that are adjacent to that vertex. In the edge list representation, each edge is represented as a tuple containing the source and destination vertex and the weight of the edge.</span></li></ol><p class="c13"><span class="c11">Trees:</span></p><ol class="c14 lst-kix_d77uocuovkri-0" start="2"><li class="c27 c13 c6 li-bullet-0"><span class="c11">Trees are special cases of graphs that have no cycles. Trees can be represented using an adjacency list, a parent array, or a child-sibling representation. In the adjacency list representation, each node is represented as a node in a linked list, and the linked list contains all the nodes that are adjacent to that node. In the parent array representation, each node is represented as an index in an array, and the value at the index represents the parent of that node. In the child-sibling representation, each node is represented as a node in a linked list, and the linked list contains all the children of that node.</span></li></ol><p class="c13"><span class="c11">Graphs:</span></p><ol class="c14 lst-kix_d77uocuovkri-0" start="3"><li class="c27 c13 c6 li-bullet-0"><span class="c11">Graphs can be represented using an adjacency matrix, an adjacency list, or an edge list. In the adjacency matrix representation, a 2D array is used to represent the graph, where the value at index [i][j] represents the weight of the edge between node i and node j. In the adjacency list representation, each node is represented as a node in a linked list, and the linked list contains all the nodes that are adjacent to that node. In the edge list representation, each edge is represented as a tuple containing the source and destination vertex and the weight of the edge.</span></li></ol><p class="c4"><span class="c11">Overall, the choice of data structure for representing sparse graphs, trees, and graphs depends on the specific use case and the operations that need to be performed on the data.</span></p><p class="c26 c41"><span class="c11"></span></p><p class="c13"><span class="c23 c21">Here&#39;s an example C program for representing an undirected graph using adjacency list:</span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13"><span class="c5">#include &lt;stdio.h&gt;</span></p><p class="c13"><span class="c5">#include &lt;stdlib.h&gt;</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">// A structure to represent a node in the adjacency list</span></p><p class="c13"><span class="c5">struct Node {</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; int dest;</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; struct Node* next;</span></p><p class="c13"><span class="c5">};</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">// A structure to represent the adjacency list</span></p><p class="c13"><span class="c5">struct AdjList {</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; struct Node* head;</span></p><p class="c13"><span class="c5">};</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">// A structure to represent the graph</span></p><p class="c13"><span class="c5">struct Graph {</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; int numVertices;</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; struct AdjList* array;</span></p><p class="c13"><span class="c5">};</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">// Function to create a new node in the adjacency list</span></p><p class="c13"><span class="c5">struct Node* newAdjListNode(int dest) {</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; struct Node* newNode = (struct Node*) malloc(sizeof(struct Node));</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; newNode-&gt;dest = dest;</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; newNode-&gt;next = NULL;</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; return newNode;</span></p><p class="c13"><span class="c5">}</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">// Function to create a graph with the given number of vertices</span></p><p class="c13"><span class="c5">struct Graph* createGraph(int numVertices) {</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; struct Graph* graph = (struct Graph*) malloc(sizeof(struct Graph));</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; graph-&gt;numVertices = numVertices;</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">&nbsp; &nbsp; // Create an array of adjacency lists</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; graph-&gt;array = (struct AdjList*) malloc(numVertices * sizeof(struct AdjList));</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">&nbsp; &nbsp; // Initialize each adjacency list as empty</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; for (int i = 0; i &lt; numVertices; i++) {</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; graph-&gt;array[i].head = NULL;</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; }</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">&nbsp; &nbsp; return graph;</span></p><p class="c13"><span class="c5">}</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">// Function to add an edge to the graph</span></p><p class="c13"><span class="c5">void addEdge(struct Graph* graph, int src, int dest) {</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; // Add an edge from src to dest</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; struct Node* newNode = newAdjListNode(dest);</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; newNode-&gt;next = graph-&gt;array[src].head;</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; graph-&gt;array[src].head = newNode;</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">&nbsp; &nbsp; // Add an edge from dest to src since it is an undirected graph</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; newNode = newAdjListNode(src);</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; newNode-&gt;next = graph-&gt;array[dest].head;</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; graph-&gt;array[dest].head = newNode;</span></p><p class="c13"><span class="c5">}</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">// Function to print the graph</span></p><p class="c13"><span class="c5">void printGraph(struct Graph* graph) {</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; for (int i = 0; i &lt; graph-&gt;numVertices; i++) {</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;Adjacency list of vertex %d\nhead&quot;, i);</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; struct Node* temp = graph-&gt;array[i].head;</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; while (temp != NULL) {</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; printf(&quot; -&gt; %d&quot;, temp-&gt;dest);</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; temp = temp-&gt;next;</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; }</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; &nbsp; &nbsp; printf(&quot;\n&quot;);</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; }</span></p><p class="c13"><span class="c5">}</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">int main() {</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; // Create a graph with 5 vertices</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; struct Graph* graph = createGraph(5);</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">&nbsp; &nbsp; // Add edges to the graph</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; addEdge(graph, 0, 1);</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; addEdge(graph, 0, 4);</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; addEdge(graph, 1, 2);</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; addEdge(graph, 1, 3);</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; addEdge(graph, 1, 4);</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; addEdge(graph, 2, 3);</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; addEdge(graph, 3, 4);</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">&nbsp; &nbsp; // Print the graph</span></p><p class="c13"><span class="c5">&nbsp; &nbsp; printGraph(graph);</span></p><p class="c13 c26"><span class="c5"></span></p><p class="c13"><span class="c5">&nbsp; &nbsp; return 0;</span></p><p class="c13"><span class="c5">}</span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13"><span class="c19">This program uses an adjacency list to represent an undirected graph. The </span><span class="c21 c37">Node</span><span class="c19">&nbsp;structure represents a node in the adjacency list, and the </span><span class="c37 c21">AdjList</span><span class="c19">&nbsp;structure represents the adjacency list for a vertex. The </span><span class="c37 c21">Graph</span><span class="c19">&nbsp;structure represents the graph and contains an array of adjacency lists. The </span><span class="c37 c21">createGraph()</span><span class="c19">&nbsp;function creates a new graph with the given number of vertices, and the </span><span class="c37 c21">addEdge()</span><span class="c19">&nbsp;function adds an edge between two vertices. Finally, the </span><span class="c37 c21">printGraph()</span><span class="c23 c21">&nbsp;function prints the adjacency list for each vertex in the graph.</span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13">

                                                    </fieldset>
                                                    <fieldset class="topic-card">   <center>
                                                           <span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 601.70px; height: 516.00px;" >
                                                           
                                                           <img alt="" src="images/image1.png" style="width: 601.70px; height: 516.00px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c13 c26"><span class="c23 c21"></span></p><p class="c13 c26"><span class="c23 c21"></center></span></p>

        </p>
	</fieldset >
         
	</main>
</body>
</html>






